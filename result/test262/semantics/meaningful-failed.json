[{
  "algo": "ReturnStatement1Evaluation0",
  "cond": "(= __x2__ CONST_async)",
  "covered": true,
  "elseCovered": "assert . sameValue ( 0 , 0 ) ;",
  "inst": "if (= __x2__ CONST_async) ... else ..."
}, {
  "algo": "MemberExpression2Contains0",
  "cond": "(= __x1__ true)",
  "covered": true,
  "elseCovered": "var fooCalled = false ; function foo ( ) { fooCalled = true ; } var o = { } ; assert . throws ( TypeError , function ( ) { eval ( \"o.bar( foo() );\" ) ; $ERROR ( \"o.bar does not exist!\" ) ; } ) ; assert . sameValue ( fooCalled , true , 'fooCalled' ) ;",
  "inst": "if (= __x1__ true) ... else ..."
}, {
  "algo": "MemberExpression2Contains0",
  "cond": "(is-instance-of symbol ReservedWord)",
  "covered": true,
  "elseCovered": "var fooCalled = false ; function foo ( ) { fooCalled = true ; } var o = { } ; assert . throws ( TypeError , function ( ) { eval ( \"o.bar( foo() );\" ) ; $ERROR ( \"o.bar does not exist!\" ) ; } ) ; assert . sameValue ( fooCalled , true , 'fooCalled' ) ;",
  "inst": "if (is-instance-of symbol ReservedWord) ... else ..."
}, {
  "algo": "MemberExpression2Contains0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "var fooCalled = false ; function foo ( ) { fooCalled = true ; } var o = { } ; assert . throws ( TypeError , function ( ) { eval ( \"o.bar( foo() );\" ) ; $ERROR ( \"o.bar does not exist!\" ) ; } ) ; assert . sameValue ( fooCalled , true , 'fooCalled' ) ;",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "MemberExpression2Contains0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "var fooCalled = false ; function foo ( ) { fooCalled = true ; } var o = { } ; assert . throws ( TypeError , function ( ) { eval ( \"o.bar( foo() );\" ) ; $ERROR ( \"o.bar does not exist!\" ) ; } ) ; assert . sameValue ( fooCalled , true , 'fooCalled' ) ;",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "LiteralPropertyName0Contains0",
  "cond": "(is-instance-of symbol ReservedWord)",
  "covered": true,
  "elseCovered": "eval ( \"({foo : 1, get foo(){}});\" ) ;",
  "inst": "if (is-instance-of symbol ReservedWord) ... else ..."
}, {
  "algo": "LiteralPropertyName0Contains0",
  "cond": "__x0__",
  "covered": true,
  "elseCovered": "eval ( \"({foo : 1, get foo(){}});\" ) ;",
  "inst": "if __x0__ ... else ..."
}, {
  "algo": "LiteralPropertyName0Contains0",
  "cond": "__x0__",
  "covered": true,
  "elseCovered": "eval ( \"({foo : 1, get foo(){}});\" ) ;",
  "inst": "if __x0__ ... else ..."
}, {
  "algo": "Literal1Evaluation0",
  "cond": "(= (get-syntax BooleanLiteral) \"true\")",
  "covered": true,
  "inst": "if (= (get-syntax BooleanLiteral) \"true\") ... else ...",
  "thenCovered": "assert ( NaN !== NaN ) ;"
}, {
  "algo": "CallExpression0Evaluation0",
  "cond": "(= __x10__ true)",
  "covered": true,
  "inst": "if (= __x10__ true) ... else ...",
  "thenCovered": "let x ; eval ( 'var x;' ) ;"
}, {
  "algo": "AssignmentExpression5Evaluation0",
  "cond": "(= op \"*\")",
  "covered": true,
  "inst": "if (= op \"*\") ... else ...",
  "thenCovered": "var _11_13_2_12 = 5 ; _11_13_2_12 *= 2 ; assert . sameValue ( _11_13_2_12 , 10 , '_11_13_2_12' ) ;"
}, {
  "algo": "PrimaryExpression12HasName0",
  "cond": "(= __x1__ false)",
  "covered": true,
  "elseCovered": "assert . throws ( ReferenceError , function ( ) { var x = ( class x extends x { } ) ; } ) ;",
  "inst": "if (= __x1__ false) ... else ..."
}, {
  "algo": "CallExpression5Contains0",
  "cond": "(= __x1__ true)",
  "covered": true,
  "elseCovered": "eval ( \" Function(\\\"this.feat=1\\\").call(void 0) \" ) ; if ( this [ \"feat\" ] !== 1 ) { $ERROR ( '#1: If thisArg is null or undefined, the called function is passed the global object as the this value' ) ; }",
  "inst": "if (= __x1__ true) ... else ..."
}, {
  "algo": "CallExpression5Contains0",
  "cond": "(is-instance-of symbol ReservedWord)",
  "covered": true,
  "elseCovered": "eval ( \" Function(\\\"this.feat=1\\\").call(void 0) \" ) ; if ( this [ \"feat\" ] !== 1 ) { $ERROR ( '#1: If thisArg is null or undefined, the called function is passed the global object as the this value' ) ; }",
  "inst": "if (is-instance-of symbol ReservedWord) ... else ..."
}, {
  "algo": "CallExpression5Contains0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "eval ( \" Function(\\\"this.feat=1\\\").call(void 0) \" ) ; if ( this [ \"feat\" ] !== 1 ) { $ERROR ( '#1: If thisArg is null or undefined, the called function is passed the global object as the this value' ) ; }",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "CallExpression5Contains0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "eval ( \" Function(\\\"this.feat=1\\\").call(void 0) \" ) ; if ( this [ \"feat\" ] !== 1 ) { $ERROR ( '#1: If thisArg is null or undefined, the called function is passed the global object as the this value' ) ; }",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "IfStatement0HasCallInTailPosition0",
  "cond": "(= has true)",
  "covered": true,
  "elseCovered": "assert . sameValue ( 0 , 0 ) ;",
  "inst": "if (= has true) ... else ..."
}, {
  "algo": "ArrowFunction0Contains0",
  "cond": "(! (|| (|| (|| (|| (is-instance-of symbol NewTarget) (is-instance-of symbol SuperProperty)) (is-instance-of symbol SuperCall)) (= symbol \"super\")) (= symbol \"this\")))",
  "covered": true,
  "elseCovered": "var result = eval ( '{length: 3000}() => 42;;' ) ; var expected = 3000 ;",
  "inst": "if (! (|| (|| (|| (|| (is-instance-of symbol NewTarget) (is-instance-of symbol SuperProperty)) (is-instance-of symbol SuperCall)) (= symbol \"super\")) (= symbol \"this\"))) ... else ..."
}, {
  "algo": "ArrowFunction0Contains0",
  "cond": "(= __x1__ true)",
  "covered": true,
  "elseCovered": "var result = eval ( '{length: 3000}() => 42;;' ) ; var expected = 3000 ;",
  "inst": "if (= __x1__ true) ... else ..."
}, {
  "algo": "UnaryExpression1Evaluation0",
  "cond": "(= __x3__ true)",
  "covered": true,
  "elseCovered": "assert . throws ( TypeError , function ( ) { delete Math . LN2 ; } ) ;",
  "inst": "if (= __x3__ true) ... else ..."
}, {
  "algo": "UnaryExpression1Evaluation0",
  "cond": "(= __x6__ true)",
  "covered": true,
  "inst": "if (= __x6__ true) ... else ...",
  "thenCovered": "assert . throws ( TypeError , function ( ) { delete Math . LN2 ; } ) ;"
}, {
  "algo": "ArrowParameters0IteratorBindingInitialization0",
  "cond": "__x1__",
  "covered": true,
  "elseCovered": "var square = x => x * x ; assert . sameValue ( square ( 3 ) , 9 ) ;",
  "inst": "if __x1__ ... else ..."
}, {
  "algo": "ArrowParameters0IteratorBindingInitialization0",
  "cond": "__x3__",
  "covered": true,
  "elseCovered": "var square = x => x * x ; assert . sameValue ( square ( 3 ) , 9 ) ;",
  "inst": "if __x3__ ... else ..."
}, {
  "algo": "BindingElement1IteratorBindingInitialization1",
  "cond": "(= iteratorRecord[\"Done\"] false)",
  "covered": true,
  "inst": "if (= iteratorRecord[\"Done\"] false) ... else ...",
  "thenCovered": "assert . throws ( TypeError , function ( ) { let [ { x } ] = [ ] ; } ) ;"
}, {
  "algo": "BindingElement1IteratorBindingInitialization1",
  "cond": "__x1__",
  "covered": true,
  "elseCovered": "assert . throws ( TypeError , function ( ) { let [ { x } ] = [ ] ; } ) ;",
  "inst": "if __x1__ ... else ..."
}, {
  "algo": "BindingElement1IteratorBindingInitialization1",
  "cond": "__x3__",
  "covered": true,
  "elseCovered": "assert . throws ( TypeError , function ( ) { let [ [ x ] ] = [ null ] ; } ) ;",
  "inst": "if __x3__ ... else ..."
}, {
  "algo": "ArrayCreate",
  "cond": "(= length -0.0)",
  "covered": true,
  "elseCovered": "{ } [ ] ; ;",
  "inst": "if (= length -0.0) ... else ..."
}, {
  "algo": "ArraySetLength",
  "cond": "(= succeeded false)",
  "covered": true,
  "elseCovered": "var arr = [ 0 , 1 ] ; Object . defineProperties ( arr , { length : { value : 0 } } ) ; assert . sameValue ( arr . length , 0 , 'arr.length' ) ;",
  "inst": "if (= succeeded false) ... else ..."
}, {
  "algo": "ArraySpeciesCreate",
  "cond": "(= length -0.0)",
  "covered": true,
  "elseCovered": "assert . throws ( TypeError , function ( ) { TypedArray . of ( ) ; } ) ;",
  "inst": "if (= length -0.0) ... else ..."
}, {
  "algo": "ArraySpeciesCreate",
  "cond": "(! (= thisRealm realmC))",
  "covered": true,
  "elseCovered": "assert . throws ( TypeError , function ( ) { TypedArray . of ( ) ; } ) ;",
  "inst": "if (! (= thisRealm realmC)) ... else ..."
}, {
  "algo": "ArraySpeciesCreate",
  "cond": "(= __x7__ true)",
  "covered": false,
  "inst": "if (= __x7__ true) ... else ..."
}, {
  "algo": "AssignmentElement0IteratorDestructuringAssignmentEvaluation1",
  "cond": "__x4__",
  "covered": true,
  "elseCovered": "var x ; assert . throws ( TypeError , function ( ) { 0 , [ { x } ] = [ , ] ; } ) ;",
  "inst": "if __x4__ ... else ..."
}, {
  "algo": "AssignmentRestElement0IteratorDestructuringAssignmentEvaluation0",
  "cond": "__x5__",
  "covered": true,
  "elseCovered": "const c = null ; assert . throws ( TypeError , function ( ) { 0 , [ ... c ] = [ 1 ] ; } ) ;",
  "inst": "if __x5__ ... else ..."
}, {
  "algo": "AsyncFunctionBody0EvaluateBody0",
  "cond": "(! __x2__)",
  "covered": true,
  "inst": "if (! __x2__) ... else ...",
  "thenCovered": "let called ; async function foo ( ) { called = true ; await new Promise ( ) ; } foo ( ) ; assert ( called ) ;"
}, {
  "algo": "AsyncFunctionStart",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] asyncContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] asyncContext) ... else ...",
  "thenCovered": "let called ; async function foo ( ) { called = true ; await new Promise ( ) ; } foo ( ) ; assert ( called ) ;"
}, {
  "algo": "AsyncFunctionStart",
  "cond": "(= result[\"Type\"] CONST_return)",
  "covered": true,
  "elseCovered": "let called ; async function foo ( ) { called = true ; await new Promise ( ) ; } foo ( ) ; assert ( called ) ;",
  "inst": "if (= result[\"Type\"] CONST_return) ... else ..."
}, {
  "algo": "AsyncFunctionStart",
  "cond": "(= asyncContext[\"ReturnCont\"] absent)",
  "covered": true,
  "inst": "if (= asyncContext[\"ReturnCont\"] absent) ... else ...",
  "thenCovered": "let called ; async function foo ( ) { called = true ; await new Promise ( ) ; } foo ( ) ; assert ( called ) ;"
}, {
  "algo": "AsyncGeneratorEnqueue",
  "cond": "(|| (! (= __x1__ Object)) (= generator[\"AsyncGeneratorState\"] absent))",
  "covered": true,
  "elseCovered": "async function * g ( ) { } var result = g ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (|| (! (= __x1__ Object)) (= generator[\"AsyncGeneratorState\"] absent)) ... else ..."
}, {
  "algo": "AsyncGeneratorEnqueue",
  "cond": "(! (= state CONST_executing))",
  "covered": true,
  "inst": "if (! (= state CONST_executing)) ... else ...",
  "thenCovered": "async function * g ( ) { } var result = g ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= state CONST_awaitingreturn)",
  "covered": true,
  "elseCovered": "async function * g ( ) { } var result = g ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (= state CONST_awaitingreturn) ... else ..."
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= state CONST_suspendedStart)",
  "covered": true,
  "inst": "if (= state CONST_suspendedStart) ... else ...",
  "thenCovered": "async function * g ( ) { } var result = g ( ) . return ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= state CONST_completed)",
  "covered": true,
  "inst": "if (= state CONST_completed) ... else ...",
  "thenCovered": "async function * g ( ) { } var result = g ( ) . return ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= completion[\"Type\"] CONST_return)",
  "covered": true,
  "inst": "if (= completion[\"Type\"] CONST_return) ... else ...",
  "thenCovered": "async function * g ( ) { } var result = g ( ) . return ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= state CONST_completed)",
  "covered": true,
  "elseCovered": "async function * g ( ) { } var result = g ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (= state CONST_completed) ... else ..."
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= genContext[\"ReturnCont\"] absent)",
  "covered": true,
  "inst": "if (= genContext[\"ReturnCont\"] absent) ... else ...",
  "thenCovered": "async function * g ( ) { } var result = g ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorStart",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext) ... else ...",
  "thenCovered": "async function * g ( ) { } var result = g ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorStart",
  "cond": "(! (= result[\"Type\"] CONST_return))",
  "covered": false,
  "inst": "if (! (= result[\"Type\"] CONST_return)) ... else ..."
}, {
  "algo": "Await",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] asyncContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] asyncContext) ... else ...",
  "thenCovered": "function * g ( ) { } async function * asyncg ( ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "BigIntCOLONCOLONremainder",
  "cond": "(= n 0n)",
  "covered": true,
  "elseCovered": "assert . sameValue ( Object ( 2n ) % 2n , 0n , 'The result of (Object(2n) % 2n) is 0n' ) ; assert . sameValue ( 2n % Object ( 2n ) , 0n , 'The result of (2n % Object(2n)) is 0n' ) ; assert . sameValue ( { [ Symbol . toPrimitive ] : function ( ) { return 2n ; } } % 2n , 0n , 'The result of (({[Symbol.toPrimitive]: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { [ Symbol . toPrimitive ] : function ( ) { return 2n ; } } , 0n , 'The result of (2n % {[Symbol.toPrimitive]: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { valueOf : function ( ) { return 2n ; } } % 2n , 0n , 'The result of (({valueOf: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { valueOf : function ( ) { return 2n ; } } , 0n , 'The result of (2n % {valueOf: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { toString : function ( ) { return 2n ; } } % 2n , 0n , 'The result of (({toString: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { toString : function ( ) { return 2n ; } } , 0n , 'The result of (2n % {toString: function() {return 2n;}}) is 0n' ) ;",
  "inst": "if (= n 0n) ... else ..."
}, {
  "algo": "BindingRestElement1IteratorBindingInitialization0",
  "cond": "(= iteratorRecord[\"Done\"] false)",
  "covered": true,
  "inst": "if (= iteratorRecord[\"Done\"] false) ... else ...",
  "thenCovered": "var [ ... { length } ] = [ 1 , 2 , 3 ] ; assert . sameValue ( length , 3 ) ;"
}, {
  "algo": "BindingRestElement1IteratorBindingInitialization0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "var [ ... { length } ] = [ 1 , 2 , 3 ] ; assert . sameValue ( length , 3 ) ;",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "BindingRestElement1IteratorBindingInitialization0",
  "cond": "__x7__",
  "covered": true,
  "elseCovered": "var [ ... { length } ] = [ 1 , 2 , 3 ] ; assert . sameValue ( length , 3 ) ;",
  "inst": "if __x7__ ... else ..."
}, {
  "algo": "BreakableStatement1LabelledEvaluation0",
  "cond": "(= stmtResult[\"Target\"] CONST_empty)",
  "covered": true,
  "inst": "if (= stmtResult[\"Target\"] CONST_empty) ... else ...",
  "thenCovered": "function SwitchTest ( value ) { var result = 0 ; switch ( value ) { case 0 : switch ( value ) { case 0 : result += 3 ; break ; default : result += 32 ; break ; } result *= 2 ; break ; result = 3 ; default : result += 32 ; break ; } return result ; } var x = SwitchTest ( 0 ) ; if ( x !== 6 ) $ERROR ( \"#1: SwitchTest(0) === 6. Actual:  SwitchTest(0) ===\" + SwitchTest ( 0 ) ) ;"
}, {
  "algo": "BreakableStatement1LabelledEvaluation0",
  "cond": "(= stmtResult[\"Value\"] CONST_empty)",
  "covered": true,
  "elseCovered": "function SwitchTest ( value ) { var result = 0 ; switch ( value ) { case 0 : switch ( value ) { case 0 : result += 3 ; break ; default : result += 32 ; break ; } result *= 2 ; break ; result = 3 ; default : result += 32 ; break ; } return result ; } var x = SwitchTest ( 0 ) ; if ( x !== 6 ) $ERROR ( \"#1: SwitchTest(0) === 6. Actual:  SwitchTest(0) ===\" + SwitchTest ( 0 ) ) ;",
  "inst": "if (= stmtResult[\"Value\"] CONST_empty) ... else ..."
}, {
  "algo": "BuiltinFunctionObjectDOTCall",
  "cond": "(= callerContext null)",
  "covered": true,
  "elseCovered": "1 * { } ;",
  "inst": "if (= callerContext null) ... else ..."
}, {
  "algo": "BuiltinFunctionObjectDOTConstruct",
  "cond": "(= callerContext null)",
  "covered": true,
  "elseCovered": "var _13_0_4_17_fun = new Function ( 'eval = 42;' ) ;",
  "inst": "if (= callerContext null) ... else ..."
}, {
  "algo": "BuiltinFunctionObjectDOTConstruct",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] calleeContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] calleeContext) ... else ...",
  "thenCovered": "assert . throws ( TypeError , function ( ) { new WeakSet ( { } ) ; } ) ;"
}, {
  "algo": "CanonicalNumericIndexString",
  "cond": "(= argument \"-0\")",
  "covered": true,
  "elseCovered": "var x = \"\" . search ( ) ;",
  "inst": "if (= argument \"-0\") ... else ..."
}, {
  "algo": "CaseBlock1HasCallInTailPosition3",
  "cond": "(! (= CaseClauses1 absent))",
  "covered": true,
  "inst": "if (! (= CaseClauses1 absent)) ... else ...",
  "thenCovered": "function SwitchTest ( value ) { var result = 0 ; switch ( value ) { case 0 : result += 2 ; case 1 : result += 4 ; break ; case 2 : result += 8 ; case isNaN ( value ) : result += 16 ; default : result += 32 ; break ; case null : result += 64 ; case isNaN : result += 128 ; break ; case Infinity : result += 256 ; case 2 + 3 : result += 512 ; break ; case undefined : result += 1024 ; } return result ; } var n = Number ( false ) ; if ( ! ( SwitchTest ( n ) === 6 ) ) { $ERROR ( \"#1: SwitchTest(Number(false)) === 6. Actual:  SwitchTest(Number(false)) ===\" + SwitchTest ( n ) ) ; } if ( ! ( SwitchTest ( parseInt ) === 32 ) ) { $ERROR ( \"#2: SwitchTest(parseInt) === 32. Actual:  SwitchTest(parseInt) ===\" + SwitchTest ( parseInt ) ) ; } if ( ! ( SwitchTest ( isNaN ) === 128 ) ) { $ERROR ( \"#3: SwitchTest(isNaN) === 128. Actual:  SwitchTest(isNaN) ===\" + SwitchTest ( isNaN ) ) ; } if ( ! ( SwitchTest ( true ) === 32 ) ) { $ERROR ( \"#6: SwitchTest(true) === 32. Actual:  SwitchTest(true) ===\" + SwitchTest ( true ) ) ; } if ( ! ( SwitchTest ( false ) === 48 ) ) { $ERROR ( \"#7: SwitchTest(false) === 48. Actual:  SwitchTest(false) ===\" + SwitchTest ( false ) ) ; } if ( ! ( SwitchTest ( null ) === 192 ) ) { $ERROR ( \"#8: SwitchTest(null) === 192. Actual:  SwitchTest(null) ===\" + SwitchTest ( null ) ) ; } if ( ! ( SwitchTest ( void 0 ) === 1024 ) ) { $ERROR ( \"#9: SwitchTest(void 0) === 1024. Actual:  SwitchTest(void 0) ===\" + SwitchTest ( void 0 ) ) ; } if ( ! ( SwitchTest ( NaN ) === 32 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 32. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; } if ( ! ( SwitchTest ( Infinity ) === 768 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 768. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; }"
}, {
  "algo": "CaseBlock1LexicallyScopedDeclarations3",
  "cond": "(< __x6__ __x5__[\"length\"])",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( '1; switch (\"a\") { default: case \"a\": break; }' ) , undefined ) ; assert . sameValue ( eval ( '2; switch (\"a\") { default: case \"a\": { 3; break; } }' ) , 3 ) ; assert . sameValue ( eval ( '4; do { switch (\"a\") { default: case \"a\": continue; } } while (false)' ) , undefined ) ; assert . sameValue ( eval ( '5; do { switch (\"a\") { default: case \"a\": { 6; continue; } } } while (false)' ) , 6 ) ;",
  "inst": "while (< __x6__ __x5__[\"length\"]) { ... }"
}, {
  "algo": "CaseBlock1VarDeclaredNames3",
  "cond": "(< __x6__ __x5__[\"length\"])",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( '1; switch (\"a\") { default: case \"a\": break; }' ) , undefined ) ; assert . sameValue ( eval ( '2; switch (\"a\") { default: case \"a\": { 3; break; } }' ) , 3 ) ; assert . sameValue ( eval ( '4; do { switch (\"a\") { default: case \"a\": continue; } } while (false)' ) , undefined ) ; assert . sameValue ( eval ( '5; do { switch (\"a\") { default: case \"a\": { 6; continue; } } } while (false)' ) , 6 ) ;",
  "inst": "while (< __x6__ __x5__[\"length\"]) { ... }"
}, {
  "algo": "CaseBlock1VarScopedDeclarations3",
  "cond": "(< __x6__ __x5__[\"length\"])",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( '1; switch (\"a\") { default: case \"a\": break; }' ) , undefined ) ; assert . sameValue ( eval ( '2; switch (\"a\") { default: case \"a\": { 3; break; } }' ) , 3 ) ; assert . sameValue ( eval ( '4; do { switch (\"a\") { default: case \"a\": continue; } } while (false)' ) , undefined ) ; assert . sameValue ( eval ( '5; do { switch (\"a\") { default: case \"a\": { 6; continue; } } } while (false)' ) , 6 ) ;",
  "inst": "while (< __x6__ __x5__[\"length\"]) { ... }"
}, {
  "algo": "CaseClause0HasCallInTailPosition1",
  "cond": "(! (= StatementList absent))",
  "covered": true,
  "inst": "if (! (= StatementList absent)) ... else ...",
  "thenCovered": "var callCount = 0 ; ( function f ( n ) { if ( n === 0 ) { callCount += 1 ; return ; } switch ( 0 ) { case 0 : return f ( n - 1 ) ; } } ( $MAX_ITERATIONS ) ) ; assert . sameValue ( callCount , 1 ) ;"
}, {
  "algo": "CaseClauses1HasCallInTailPosition0",
  "cond": "(= has true)",
  "covered": true,
  "elseCovered": "function SwitchTest ( value ) { var result = 0 ; switch ( value ) { case 0 : result += 2 ; case 1 : result += 4 ; break ; case 2 : result += 8 ; case isNaN ( value ) : result += 16 ; default : result += 32 ; break ; case null : result += 64 ; case isNaN : result += 128 ; break ; case Infinity : result += 256 ; case 2 + 3 : result += 512 ; break ; case undefined : result += 1024 ; } return result ; } var n = Number ( false ) ; if ( ! ( SwitchTest ( n ) === 6 ) ) { $ERROR ( \"#1: SwitchTest(Number(false)) === 6. Actual:  SwitchTest(Number(false)) ===\" + SwitchTest ( n ) ) ; } if ( ! ( SwitchTest ( parseInt ) === 32 ) ) { $ERROR ( \"#2: SwitchTest(parseInt) === 32. Actual:  SwitchTest(parseInt) ===\" + SwitchTest ( parseInt ) ) ; } if ( ! ( SwitchTest ( isNaN ) === 128 ) ) { $ERROR ( \"#3: SwitchTest(isNaN) === 128. Actual:  SwitchTest(isNaN) ===\" + SwitchTest ( isNaN ) ) ; } if ( ! ( SwitchTest ( true ) === 32 ) ) { $ERROR ( \"#6: SwitchTest(true) === 32. Actual:  SwitchTest(true) ===\" + SwitchTest ( true ) ) ; } if ( ! ( SwitchTest ( false ) === 48 ) ) { $ERROR ( \"#7: SwitchTest(false) === 48. Actual:  SwitchTest(false) ===\" + SwitchTest ( false ) ) ; } if ( ! ( SwitchTest ( null ) === 192 ) ) { $ERROR ( \"#8: SwitchTest(null) === 192. Actual:  SwitchTest(null) ===\" + SwitchTest ( null ) ) ; } if ( ! ( SwitchTest ( void 0 ) === 1024 ) ) { $ERROR ( \"#9: SwitchTest(void 0) === 1024. Actual:  SwitchTest(void 0) ===\" + SwitchTest ( void 0 ) ) ; } if ( ! ( SwitchTest ( NaN ) === 32 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 32. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; } if ( ! ( SwitchTest ( Infinity ) === 768 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 768. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; }",
  "inst": "if (= has true) ... else ..."
}, {
  "algo": "CaseClauses1LexicallyScopedDeclarations0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "let x = 'outside' ; var probe1 , probe2 ; switch ( null ) { case null : let x = 'inside' ; probe1 = function ( ) { return x ; } ; case null : probe2 = function ( ) { return x ; } ; } assert . sameValue ( probe1 ( ) , 'inside' , 'from first `case` clause' ) ; assert . sameValue ( probe2 ( ) , 'inside' , 'from second `case` clause' ) ; assert . sameValue ( x , 'outside' ) ;",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "CaseClauses1VarDeclaredNames0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "let x = 'outside' ; var probe1 , probe2 ; switch ( null ) { case null : let x = 'inside' ; probe1 = function ( ) { return x ; } ; case null : probe2 = function ( ) { return x ; } ; } assert . sameValue ( probe1 ( ) , 'inside' , 'from first `case` clause' ) ; assert . sameValue ( probe2 ( ) , 'inside' , 'from second `case` clause' ) ; assert . sameValue ( x , 'outside' ) ;",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "CaseClauses1VarScopedDeclarations0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "let x = 'outside' ; var probe1 , probe2 ; switch ( null ) { case null : let x = 'inside' ; probe1 = function ( ) { return x ; } ; case null : probe2 = function ( ) { return x ; } ; } assert . sameValue ( probe1 ( ) , 'inside' , 'from first `case` clause' ) ; assert . sameValue ( probe2 ( ) , 'inside' , 'from second `case` clause' ) ; assert . sameValue ( x , 'outside' ) ;",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "ClassElementList0ConstructorMethod0",
  "cond": "(is-instance-of ClassElement ClassElement2)",
  "covered": true,
  "elseCovered": "class C { constructor ( ) { } }",
  "inst": "if (is-instance-of ClassElement ClassElement2) ... else ..."
}, {
  "algo": "ClassElementList0NonConstructorMethodDefinitions0",
  "cond": "(is-instance-of ClassElement ClassElement2)",
  "covered": true,
  "elseCovered": "class C { constructor ( ) { } }",
  "inst": "if (is-instance-of ClassElement ClassElement2) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(is-instance-of symbol ClassBody)",
  "covered": true,
  "elseCovered": "var result = eval ( 'class C {}{};' ) ; assert . sameValue ( result , undefined ) ;",
  "inst": "if (is-instance-of symbol ClassBody) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(is-instance-of symbol ClassHeritage)",
  "covered": true,
  "elseCovered": "var result = eval ( 'class C {}{};' ) ; assert . sameValue ( result , undefined ) ;",
  "inst": "if (is-instance-of symbol ClassHeritage) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(! (= ClassHeritage absent))",
  "covered": false,
  "inst": "if (! (= ClassHeritage absent)) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(= ClassHeritage absent)",
  "covered": true,
  "inst": "if (= ClassHeritage absent) ... else ...",
  "thenCovered": "var result = eval ( 'class C {}{};' ) ; assert . sameValue ( result , undefined ) ;"
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(= inHeritage true)",
  "covered": true,
  "elseCovered": "var result = eval ( 'class C {}{};' ) ; assert . sameValue ( result , undefined ) ;",
  "inst": "if (= inHeritage true) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(= ClassBody absent)",
  "covered": true,
  "inst": "if (= ClassBody absent) ... else ...",
  "thenCovered": "var result = eval ( 'class C {}{};' ) ; assert . sameValue ( result , undefined ) ;"
}, {
  "algo": "CreateBuiltinFunction",
  "cond": "(= realm absent)",
  "covered": true,
  "inst": "if (= realm absent) ... else ...",
  "thenCovered": "assert ( NaN !== NaN ) ;"
}, {
  "algo": "CreateBuiltinFunction",
  "cond": "(= prototype absent)",
  "covered": true,
  "inst": "if (= prototype absent) ... else ...",
  "thenCovered": "assert ( NaN !== NaN ) ;"
}, {
  "algo": "CreateBuiltinFunction",
  "cond": "(= steps[\"length\"] absent)",
  "covered": true,
  "elseCovered": "assert ( NaN !== NaN ) ;",
  "inst": "if (= steps[\"length\"] absent) ... else ..."
}, {
  "algo": "CreateListFromArrayLike",
  "cond": "(= elementTypes absent)",
  "covered": true,
  "inst": "if (= elementTypes absent) ... else ...",
  "thenCovered": "function fun ( ) { return ( this instanceof String ) ; } assert . sameValue ( fun . apply ( \"\" , Array ) , false , 'fun.apply(\"\", Array)' ) ;"
}, {
  "algo": "CreateListFromArrayLike",
  "cond": "(! (contains elementTypes __x5__))",
  "covered": true,
  "elseCovered": "function fun ( ) { return ( this instanceof String ) ; } assert . sameValue ( fun . apply ( \"\" , Array ) , false , 'fun.apply(\"\", Array)' ) ;",
  "inst": "if (! (contains elementTypes __x5__)) ... else ..."
}, {
  "algo": "DeclarativeEnvironmentRecordDOTInitializeBinding",
  "cond": "(! (= envRec[\"SubMap\"][N] absent))",
  "covered": true,
  "inst": "if (! (= envRec[\"SubMap\"][N] absent)) ... else ...",
  "thenCovered": ""
}, {
  "algo": "DeclarativeEnvironmentRecordDOTSetMutableBinding",
  "cond": "(= absent envRec[\"SubMap\"][N])",
  "covered": true,
  "elseCovered": "assert . throws ( ReferenceError , function ( ) { E1 ; } ) ;",
  "inst": "if (= absent envRec[\"SubMap\"][N]) ... else ..."
}, {
  "algo": "DeclarativeEnvironmentRecordDOTSetMutableBinding",
  "cond": "(= S true)",
  "covered": false,
  "inst": "if (= S true) ... else ..."
}, {
  "algo": "DeclarativeEnvironmentRecordDOTSetMutableBinding",
  "cond": "(= S true)",
  "covered": true,
  "inst": "if (= S true) ... else ...",
  "thenCovered": "const c = null ; assert . throws ( TypeError , function ( ) { 0 , [ c ] = [ 1 ] ; } ) ;"
}, {
  "algo": "DefaultClause0HasCallInTailPosition1",
  "cond": "(! (= StatementList absent))",
  "covered": true,
  "inst": "if (! (= StatementList absent)) ... else ...",
  "thenCovered": "var callCount = 0 ; ( function f ( n ) { if ( n === 0 ) { callCount += 1 ; return ; } switch ( 0 ) { default : return f ( n - 1 ) ; } } ( $MAX_ITERATIONS ) ) ; assert . sameValue ( callCount , 1 ) ;"
}, {
  "algo": "ElementList1ArrayAccumulation1",
  "cond": "(! (= Elision absent))",
  "covered": true,
  "elseCovered": "assert . throws ( ReferenceError , function ( ) { [ ... unresolvableReference ] ; } ) ;",
  "inst": "if (! (= Elision absent)) ... else ..."
}, {
  "algo": "ElementList3ArrayAccumulation1",
  "cond": "(! (= Elision absent))",
  "covered": true,
  "elseCovered": "assert . throws ( ReferenceError , function ( ) { [ 0 , ... unresolvableReference ] ; } ) ;",
  "inst": "if (! (= Elision absent)) ... else ..."
}, {
  "algo": "Elision0IteratorDestructuringAssignmentEvaluation0",
  "cond": "(= iteratorRecord[\"Done\"] false)",
  "covered": true,
  "inst": "if (= iteratorRecord[\"Done\"] false) ... else ...",
  "thenCovered": "var iter = function * ( ) { } ( ) ; iter . next ( ) ; var [ , ] = iter ;"
}, {
  "algo": "Elision1IteratorDestructuringAssignmentEvaluation0",
  "cond": "(= iteratorRecord[\"Done\"] false)",
  "covered": true,
  "inst": "if (= iteratorRecord[\"Done\"] false) ... else ...",
  "thenCovered": "var [ , , ... x ] = [ 1 , 2 ] ; assert ( Array . isArray ( x ) ) ; assert . sameValue ( x . length , 0 ) ;"
}, {
  "algo": "Elision1IteratorDestructuringAssignmentEvaluation0",
  "cond": "__x3__",
  "covered": true,
  "elseCovered": "var [ , , ... x ] = [ 1 , 2 ] ; assert ( Array . isArray ( x ) ) ; assert . sameValue ( x . length , 0 ) ;",
  "inst": "if __x3__ ... else ..."
}, {
  "algo": "Elision1IteratorDestructuringAssignmentEvaluation0",
  "cond": "(= next false)",
  "covered": true,
  "elseCovered": "var [ , , ... x ] = [ 1 , 2 ] ; assert ( Array . isArray ( x ) ) ; assert . sameValue ( x . length , 0 ) ;",
  "inst": "if (= next false) ... else ..."
}, {
  "algo": "EqualityExpression2Evaluation0",
  "cond": "(= r true)",
  "covered": false,
  "inst": "if (= r true) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= strict false)",
  "covered": true,
  "elseCovered": "let x ; eval ( 'var x;' ) ;",
  "inst": "if (= strict false) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": false,
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": false,
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= __x4__ true)",
  "covered": false,
  "inst": "if (= __x4__ true) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (= thisLex varEnv))",
  "covered": false,
  "inst": "while (! (= thisLex varEnv)) { ... }"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (= (typeof thisEnvRec) \"ObjectEnvironmentRecord\"))",
  "covered": false,
  "inst": "if (! (= (typeof thisEnvRec) \"ObjectEnvironmentRecord\")) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(< __x7__ __x6__[\"length\"])",
  "covered": false,
  "inst": "while (< __x7__ __x6__[\"length\"]) { ... }"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= __x8__ true)",
  "covered": false,
  "inst": "if (= __x8__ true) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (contains declaredFunctionNames fn))",
  "covered": true,
  "inst": "if (! (contains declaredFunctionNames fn)) ... else ...",
  "thenCovered": "var result = eval ( 'function fn() {}{};' ) ; assert . sameValue ( result , undefined ) ;"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": true,
  "elseCovered": "var result = eval ( 'function fn() {}{};' ) ; assert . sameValue ( result , undefined ) ;",
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= fnDefinable false)",
  "covered": false,
  "inst": "if (= fnDefinable false) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (contains declaredFunctionNames vn))",
  "covered": true,
  "inst": "if (! (contains declaredFunctionNames vn)) ... else ...",
  "thenCovered": "let x ; eval ( 'var x;' ) ;"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": true,
  "elseCovered": "let x ; eval ( 'var x;' ) ;",
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= vnDefinable false)",
  "covered": false,
  "inst": "if (= vnDefinable false) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (contains declaredVarNames vn))",
  "covered": true,
  "inst": "if (! (contains declaredVarNames vn)) ... else ...",
  "thenCovered": "let x ; eval ( 'var x;' ) ;"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": true,
  "elseCovered": "var result = eval ( 'function fn() {}{};' ) ; assert . sameValue ( result , undefined ) ;",
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= bindingExists false)",
  "covered": true,
  "inst": "if (= bindingExists false) ... else ...",
  "thenCovered": "var result = eval ( 'function fn() {}{};' ) ; assert . sameValue ( result , undefined ) ;"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": true,
  "elseCovered": "let x ; eval ( 'var x;' ) ;",
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= bindingExists false)",
  "covered": true,
  "inst": "if (= bindingExists false) ... else ...",
  "thenCovered": "let x ; eval ( 'var x;' ) ;"
}, {
  "algo": "FlattenIntoArray",
  "cond": "(! (< targetIndex (- 9007199254740992i 1i)))",
  "covered": true,
  "elseCovered": "var a = [ [ 0 ] , [ 1 ] ] ; var actual = [ ] . flat . bind ( a ) ( ) ; assert . compareArray ( actual , [ 0 , 1 ] , 'bound flat' ) ;",
  "inst": "if (! (< targetIndex (- 9007199254740992i 1i))) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iteratorKind absent)",
  "covered": true,
  "inst": "if (= iteratorKind absent) ... else ...",
  "thenCovered": "for ( var i in Error . prototype ) { assert . notSameValue ( i , \"name\" , 'i' ) ; }"
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iteratorKind CONST_async)",
  "covered": true,
  "elseCovered": "for ( var i in Error . prototype ) { assert . notSameValue ( i , \"name\" , 'i' ) ; }",
  "inst": "if (= iteratorKind CONST_async) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(! (= __x3__ Object))",
  "covered": true,
  "elseCovered": "for ( var i in Error . prototype ) { assert . notSameValue ( i , \"name\" , 'i' ) ; }",
  "inst": "if (! (= __x3__ Object)) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "__x15__",
  "covered": true,
  "elseCovered": "for ( var prop in this ) { if ( prop === \"NaN\" ) { $ERROR ( '#1: The NaN is DontEnum' ) ; } }",
  "inst": "if __x15__ ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iteratorKind CONST_async)",
  "covered": true,
  "elseCovered": "assert . throws ( TypeError , function ( ) { for ( let { } of [ null ] ) { return ; } } ) ;",
  "inst": "if (= iteratorKind CONST_async) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iterationKind CONST_enumerate)",
  "covered": true,
  "elseCovered": "assert . throws ( TypeError , function ( ) { for ( let { } of [ null ] ) { return ; } } ) ;",
  "inst": "if (= iterationKind CONST_enumerate) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iteratorKind CONST_async)",
  "covered": true,
  "elseCovered": "assert . throws ( TypeError , function ( ) { for ( const x of [ 1 , 2 , 3 ] ) { x ++ ; } } ) ;",
  "inst": "if (= iteratorKind CONST_async) ... else ..."
}, {
  "algo": "ForInOfHeadEvaluation",
  "cond": "(= iterationKind CONST_asynciterate)",
  "covered": true,
  "elseCovered": "var x ; assert . throws ( TypeError , function ( ) { for ( x of { } ) { } } ) ;",
  "inst": "if (= iterationKind CONST_asynciterate) ... else ..."
}, {
  "algo": "FormalParameters4ContainsExpression0",
  "cond": "(= __x0__ true)",
  "covered": true,
  "elseCovered": "var value ; function rest ( a , ... b ) { arguments [ 0 ] = 2 ; value = a ; } rest ( 1 ) ; assert . sameValue ( value , 1 ) ;",
  "inst": "if (= __x0__ true) ... else ..."
}, {
  "algo": "FromPropertyDescriptor",
  "cond": "(! (= Desc[\"Enumerable\"] absent))",
  "covered": true,
  "inst": "if (! (= Desc[\"Enumerable\"] absent)) ... else ...",
  "thenCovered": "verifyProperty ( this , \"NaN\" , { enumerable : false , writable : false , configurable : false } ) ;"
}, {
  "algo": "FromPropertyDescriptor",
  "cond": "(! (= Desc[\"Configurable\"] absent))",
  "covered": true,
  "inst": "if (! (= Desc[\"Configurable\"] absent)) ... else ...",
  "thenCovered": "verifyProperty ( this , \"NaN\" , { enumerable : false , writable : false , configurable : false } ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "__x1__",
  "covered": true,
  "elseCovered": "assert ( NaN !== NaN ) ;",
  "inst": "if __x1__ ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(! (contains functionNames fn))",
  "covered": true,
  "inst": "if (! (contains functionNames fn)) ... else ...",
  "thenCovered": "assert . throws ( ReferenceError , function ( ) { async ; function foo ( ) { } } ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(contains parameterNames \"arguments\")",
  "covered": true,
  "elseCovered": "assert ( NaN !== NaN ) ;",
  "inst": "if (contains parameterNames \"arguments\") ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(|| (contains functionNames \"arguments\") (contains lexicalNames \"arguments\"))",
  "covered": true,
  "elseCovered": "assert ( NaN !== NaN ) ;",
  "inst": "if (|| (contains functionNames \"arguments\") (contains lexicalNames \"arguments\")) ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(|| (= strict true) (= hasParameterExpressions false))",
  "covered": true,
  "inst": "if (|| (= strict true) (= hasParameterExpressions false)) ... else ...",
  "thenCovered": "assert ( NaN !== NaN ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= alreadyDeclared false)",
  "covered": true,
  "inst": "if (= alreadyDeclared false) ... else ...",
  "thenCovered": "assert ( NaN !== NaN ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= hasDuplicates true)",
  "covered": true,
  "elseCovered": "assert ( NaN !== NaN ) ;",
  "inst": "if (= hasDuplicates true) ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(|| (= strict true) (= simpleParameterList false))",
  "covered": true,
  "inst": "if (|| (= strict true) (= simpleParameterList false)) ... else ...",
  "thenCovered": "assert ( NaN !== NaN ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= strict true)",
  "covered": true,
  "inst": "if (= strict true) ... else ...",
  "thenCovered": "assert ( NaN !== NaN ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= hasDuplicates true)",
  "covered": true,
  "elseCovered": "assert ( NaN !== NaN ) ;",
  "inst": "if (= hasDuplicates true) ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(! (contains instantiatedVarNames n))",
  "covered": true,
  "inst": "if (! (contains instantiatedVarNames n)) ... else ...",
  "thenCovered": "var probe ; ( ( _ = null ) => { var x = 'inside' ; probe = function ( ) { return x ; } ; } ) ( ) ; var x = 'outside' ; assert . sameValue ( probe ( ) , 'inside' ) ; assert . sameValue ( x , 'outside' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(|| (! (contains parameterBindings n)) (contains functionNames n))",
  "covered": true,
  "inst": "if (|| (! (contains parameterBindings n)) (contains functionNames n)) ... else ...",
  "thenCovered": "var probe ; ( ( _ = null ) => { var x = 'inside' ; probe = function ( ) { return x ; } ; } ) ( ) ; var x = 'outside' ; assert . sameValue ( probe ( ) , 'inside' ) ; assert . sameValue ( x , 'outside' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= strict false)",
  "covered": true,
  "elseCovered": "assert ( NaN !== NaN ) ;",
  "inst": "if (= strict false) ... else ..."
}, {
  "algo": "FunctionEnvironmentRecordDOTGetSuperBase",
  "cond": "(= home undefined)",
  "covered": true,
  "elseCovered": "var obj = { method ( ) { return super . toString ; } } ; obj . toString = null ; assert . sameValue ( obj . method ( ) , Object . prototype . toString ) ;",
  "inst": "if (= home undefined) ... else ..."
}, {
  "algo": "FunctionEnvironmentRecordDOTHasSuperBinding",
  "cond": "(= envRec[\"ThisBindingStatus\"] CONST_lexical)",
  "covered": true,
  "elseCovered": "var s = eval ; s ( 'var eval;' ) ;",
  "inst": "if (= envRec[\"ThisBindingStatus\"] CONST_lexical) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTfrom",
  "cond": "(! (< k (- 9007199254740992i 1i)))",
  "covered": true,
  "elseCovered": "assert . sameValue ( Array . from . call ( Object , [ ] ) . constructor , Object ) ;",
  "inst": "if (! (< k (- 9007199254740992i 1i))) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTfrom",
  "cond": "(= __x28__ true)",
  "covered": true,
  "inst": "if (= __x28__ true) ... else ...",
  "thenCovered": "var obj = { 0 : 2 , 1 : 4 , 2 : 8 , 3 : 16 } ; var a = Array . from ( obj ) ; assert . sameValue ( a . length , 0 , \"Expected an array of length 0.\" ) ;"
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTconcat",
  "cond": "(! (< n (- 9007199254740992i 1i)))",
  "covered": true,
  "elseCovered": "var A = function ( _length ) { this . length = 0 ; Object . preventExtensions ( this ) ; } ; var arr = [ ] ; arr . constructor = { } ; arr . constructor [ Symbol . species ] = A ; assert . throws ( TypeError , function ( ) { arr . concat ( 1 ) ; } ) ;",
  "inst": "if (! (< n (- 9007199254740992i 1i))) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTfind",
  "cond": "(= __x4__ false)",
  "covered": true,
  "elseCovered": "var arr = [ undefined , , , 'foo' ] ; var called = 0 ; arr . find ( function ( ) { called ++ ; } ) ; assert . sameValue ( called , 4 ) ;",
  "inst": "if (= __x4__ false) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTfindIndex",
  "cond": "(= __x4__ false)",
  "covered": true,
  "elseCovered": "var arr = [ undefined , , , 'foo' ] ; var called = 0 ; arr . findIndex ( function ( ) { called ++ ; } ) ; assert . sameValue ( called , 4 ) ;",
  "inst": "if (= __x4__ false) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTslice",
  "cond": "(= kPresent true)",
  "covered": true,
  "inst": "if (= kPresent true) ... else ...",
  "thenCovered": "assert . throws ( TypeError , function ( ) { TypedArray . of ( ) ; } ) ;"
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTsplice",
  "cond": "(= fromPresent true)",
  "covered": true,
  "inst": "if (= fromPresent true) ... else ...",
  "thenCovered": "var a = [ 0 , 1 , 2 ] ; Object . defineProperty ( a , 'length' , { writable : false } ) ; assert . throws ( TypeError , function ( ) { a . splice ( 1 , 2 , 4 ) ; } ) ;"
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTtoString",
  "cond": "(= result false)",
  "covered": true,
  "elseCovered": "var i = Array . prototype . indexOf . call ( { length : [ ] } , 1 ) ; assert . sameValue ( i , - 1 , 'i' ) ;",
  "inst": "if (= result false) ... else ..."
}, {
  "algo": "GLOBALDOTAwaitFulfilledFunctions",
  "cond": "(= asyncContext[\"ReturnCont\"] absent)",
  "covered": true,
  "elseCovered": "function * g ( ) { } async function * asyncg ( ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (= asyncContext[\"ReturnCont\"] absent) ... else ..."
}, {
  "algo": "GLOBALDOTBigIntDOTprototypeDOTtoString",
  "cond": "(= x NaN)",
  "covered": true,
  "elseCovered": "for ( let r = 2 ; r <= 36 ; r ++ ) { assert . sameValue ( ( 0n ) . toString ( r ) , \"0\" , \"0, radix \" + r ) ; assert . sameValue ( ( - 1n ) . toString ( r ) , \"-1\" , \"-1, radix \" + r ) ; assert . sameValue ( ( 1n ) . toString ( r ) , \"1\" , \"1, radix \" + r ) ; }",
  "inst": "if (= x NaN) ... else ..."
}, {
  "algo": "GLOBALDOTBigIntDOTprototypeDOTtoString",
  "cond": "(= x Infinity)",
  "covered": true,
  "elseCovered": "for ( let r = 2 ; r <= 36 ; r ++ ) { assert . sameValue ( ( 0n ) . toString ( r ) , \"0\" , \"0, radix \" + r ) ; assert . sameValue ( ( - 1n ) . toString ( r ) , \"-1\" , \"-1, radix \" + r ) ; assert . sameValue ( ( 1n ) . toString ( r ) , \"1\" , \"1, radix \" + r ) ; }",
  "inst": "if (= x Infinity) ... else ..."
}, {
  "algo": "GLOBALDOTBigIntDOTprototypeDOTtoString",
  "cond": "(= x Infinity)",
  "covered": true,
  "elseCovered": "for ( let r = 2 ; r <= 36 ; r ++ ) { assert . sameValue ( ( 0n ) . toString ( r ) , \"0\" , \"0, radix \" + r ) ; assert . sameValue ( ( - 1n ) . toString ( r ) , \"-1\" , \"-1, radix \" + r ) ; assert . sameValue ( ( 1n ) . toString ( r ) , \"1\" , \"1, radix \" + r ) ; }",
  "inst": "if (= x Infinity) ... else ..."
}, {
  "algo": "GLOBALDOTFunctionDOTprototypeDOTbind",
  "cond": "(= targetHasLength true)",
  "covered": true,
  "inst": "if (= targetHasLength true) ... else ...",
  "thenCovered": "function testFunc ( ) { } testFunc . bind ( ) ;"
}, {
  "algo": "GLOBALDOTFunctionDOTprototypeDOTbind",
  "cond": "(! (= __x6__ Number))",
  "covered": true,
  "elseCovered": "function testFunc ( ) { } testFunc . bind ( ) ;",
  "inst": "if (! (= __x6__ Number)) ... else ..."
}, {
  "algo": "GLOBALDOTFunctionDOTprototypeDOTtoString",
  "cond": "(&& (= T \"String\") available)",
  "covered": true,
  "inst": "if (&& (= T \"String\") available) ... else ...",
  "thenCovered": "var funObj = function ( ) { return arguments ; } ; assert . sameValue ( typeof ( String . prototype . trim . call ( funObj ) ) , \"string\" , 'typeof(String.prototype.trim.call(funObj))' ) ;"
}, {
  "algo": "GLOBALDOTFunctionDOTprototypeDOTtoString",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "assert . throws ( TypeError , function ( ) { Function . prototype . toString . call ( { } ) ; } ) ;",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_ArrayIteratorPrototypeDOTnext",
  "cond": "(! (= __x0__ Object))",
  "covered": true,
  "elseCovered": "function foo ( ) { } foo ( ... [ ] , ) ;",
  "inst": "if (! (= __x0__ Object)) ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_ArrayIteratorPrototypeDOTnext",
  "cond": "(! (= a[\"TypedArrayName\"] absent))",
  "covered": true,
  "elseCovered": "function foo ( ) { } foo ( ... [ ] , ) ;",
  "inst": "if (! (= a[\"TypedArrayName\"] absent)) ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_ArrayIteratorPrototypeDOTnext",
  "cond": "(= __x5__ true)",
  "covered": false,
  "inst": "if (= __x5__ true) ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_StringIteratorPrototypeDOTnext",
  "cond": "(! (= __x0__ Object))",
  "covered": true,
  "elseCovered": "var result ; var vals = 'string literal' ; result = [ , ] = vals ; assert . sameValue ( result , vals ) ;",
  "inst": "if (! (= __x0__ Object)) ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_StringIteratorPrototypeDOTnext",
  "cond": "(= s undefined)",
  "covered": true,
  "elseCovered": "var result ; var vals = 'string literal' ; result = [ , ] = vals ; assert . sameValue ( result , vals ) ;",
  "inst": "if (= s undefined) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTisSafeInteger",
  "cond": "(! (< (- 9007199254740992i 1i) __x2__))",
  "covered": true,
  "elseCovered": "assert . sameValue ( Number . isSafeInteger ( 9007199254740992 ) , false , \"2**53\" ) ; assert . sameValue ( Number . isSafeInteger ( - 9007199254740992 ) , false , \"-(2**53)\" ) ;",
  "inst": "if (! (< (- 9007199254740992i 1i) __x2__)) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTfreeze",
  "cond": "(= status false)",
  "covered": true,
  "elseCovered": "[ 'z' ] . forEach ( function ( ) { Object . freeze ( Array . prototype . forEach ) ; } ) ;",
  "inst": "if (= status false) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTgetOwnPropertyDescriptors",
  "cond": "(! (= descriptor undefined))",
  "covered": true,
  "inst": "if (! (= descriptor undefined)) ... else ...",
  "thenCovered": "function fakeObject ( ) { $ERROR ( 'The overriden version of Object was called!' ) ; } fakeObject . getOwnPropertyDescriptors = Object . getOwnPropertyDescriptors ; fakeObject . keys = Object . keys ; var global = this ; global . Object = fakeObject ; assert . sameValue ( Object , fakeObject , 'Sanity check failed: could not modify the global Object' ) ; assert . sameValue ( Object . keys ( Object . getOwnPropertyDescriptors ( 'a' ) ) . length , 2 , 'Expected string primitive to have 2 descriptors' ) ;"
}, {
  "algo": "GLOBALDOTObjectDOTpreventExtensions",
  "cond": "(= status false)",
  "covered": true,
  "elseCovered": "var obj = { } ; Object . preventExtensions ( obj ) ; assert . throws ( TypeError , function ( ) { obj . len = 10 ; } ) ;",
  "inst": "if (= status false) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTprototypeDOTtoString",
  "cond": "(! (= O[\"DateValue\"] absent))",
  "covered": true,
  "elseCovered": "1 * { } ;",
  "inst": "if (! (= O[\"DateValue\"] absent)) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTprototypeDOTtoString",
  "cond": "(! (= O[\"RegExpMatcher\"] absent))",
  "covered": true,
  "elseCovered": "1 * { } ;",
  "inst": "if (! (= O[\"RegExpMatcher\"] absent)) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTseal",
  "cond": "(= status false)",
  "covered": true,
  "elseCovered": "var obj = { } ; obj . foo = 10 ; Object . seal ( obj ) ; Object . freeze ( obj ) ; assert ( Object . isFrozen ( obj ) , 'Object.isFrozen(obj) !== true' ) ;",
  "inst": "if (= status false) ... else ..."
}, {
  "algo": "GLOBALDOTPromise",
  "cond": "__x7__",
  "covered": true,
  "elseCovered": "async function * g ( ) { } var result = g ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if __x7__ ... else ..."
}, {
  "algo": "GLOBALDOTPromiseDOTallSettledRejectElementFunctions",
  "cond": "(= alreadyCalled[\"Value\"] true)",
  "covered": true,
  "elseCovered": "var p1 = Promise . resolve ( 1 ) ; var p2 = Promise . resolve ( 1 ) ; var p3 = Promise . reject ( 1 ) ; var p4 = Promise . resolve ( 1 ) ; var resolve = Promise . resolve ; var getCount = 0 ; var callCount = 0 ; Object . defineProperty ( Promise , 'resolve' , { configurable : true , get ( ) { getCount += 1 ; return function ( ) { callCount += 1 ; return resolve . apply ( Promise , arguments ) ; } ; } } ) ; Promise . allSettled ( [ p1 , p2 , p3 , p4 ] ) ; assert . sameValue ( getCount , 1 , 'Got `resolve` only once for each iterated value' ) ; assert . sameValue ( callCount , 4 , '`resolve` invoked once for each iterated value' ) ;",
  "inst": "if (= alreadyCalled[\"Value\"] true) ... else ..."
}, {
  "algo": "GLOBALDOTPromiseDOTallSettledRejectElementFunctions",
  "cond": "(= remainingElementsCount[\"Value\"] 0i)",
  "covered": true,
  "elseCovered": "var p1 = Promise . resolve ( 1 ) ; var p2 = Promise . resolve ( 1 ) ; var p3 = Promise . reject ( 1 ) ; var p4 = Promise . resolve ( 1 ) ; var resolve = Promise . resolve ; var getCount = 0 ; var callCount = 0 ; Object . defineProperty ( Promise , 'resolve' , { configurable : true , get ( ) { getCount += 1 ; return function ( ) { callCount += 1 ; return resolve . apply ( Promise , arguments ) ; } ; } } ) ; Promise . allSettled ( [ p1 , p2 , p3 , p4 ] ) ; assert . sameValue ( getCount , 1 , 'Got `resolve` only once for each iterated value' ) ; assert . sameValue ( callCount , 4 , '`resolve` invoked once for each iterated value' ) ;",
  "inst": "if (= remainingElementsCount[\"Value\"] 0i) ... else ..."
}, {
  "algo": "GLOBALDOTPromiseResolveFunctions",
  "cond": "(= __x2__ true)",
  "covered": true,
  "elseCovered": "async function * g ( ) { } var result = g ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (= __x2__ true) ... else ..."
}, {
  "algo": "GLOBALDOTPromiseResolveFunctions",
  "cond": "__x9__",
  "covered": true,
  "elseCovered": "async function * g ( ) { } var result = g ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if __x9__ ... else ..."
}, {
  "algo": "GLOBALDOTSetDOTprototypeDOTdelete",
  "cond": "__x4__",
  "covered": true,
  "inst": "if __x4__ ... else ...",
  "thenCovered": "var s = new Set ( ) ; s . add ( 1 ) ; assert . sameValue ( s . delete ( 1 ) , true , \"`s.delete(1)` returns `true`\" ) ;"
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTendsWith",
  "cond": "(= isRegExp true)",
  "covered": true,
  "elseCovered": "assert . sameValue ( 'word' . endsWith ( 'd' ) , true , '\"word\".endsWith(\"d\")' ) ;",
  "inst": "if (= isRegExp true) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTincludes",
  "cond": "(= isRegExp true)",
  "covered": true,
  "elseCovered": "assert . sameValue ( 'word' . includes ( 'w' ) , true , '\"word\".includes(\"w\")' ) ;",
  "inst": "if (= isRegExp true) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTmatchAll",
  "cond": "(= isRegExp true)",
  "covered": true,
  "elseCovered": "var obj = { } ; var returnVal = { } ; var callCount = 0 ; var thisVal , args ; obj [ Symbol . matchAll ] = function ( ) { callCount ++ ; thisVal = this ; args = arguments ; return returnVal ; } ; var str = '' ; assert . sameValue ( str . matchAll ( obj ) , returnVal ) ; assert . sameValue ( callCount , 1 , 'Invokes the method exactly once' ) ; assert . sameValue ( thisVal , obj ) ; assert . notSameValue ( args , undefined ) ; assert . sameValue ( args . length , 1 ) ; assert . sameValue ( args [ 0 ] , str ) ;",
  "inst": "if (= isRegExp true) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTmatchAll",
  "cond": "(! (contains __x5__ \"g\"))",
  "covered": false,
  "inst": "if (! (contains __x5__ \"g\")) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTmatchAll",
  "cond": "(! (= matcher undefined))",
  "covered": true,
  "inst": "if (! (= matcher undefined)) ... else ...",
  "thenCovered": "var obj = { } ; var returnVal = { } ; var callCount = 0 ; var thisVal , args ; obj [ Symbol . matchAll ] = function ( ) { callCount ++ ; thisVal = this ; args = arguments ; return returnVal ; } ; var str = '' ; assert . sameValue ( str . matchAll ( obj ) , returnVal ) ; assert . sameValue ( callCount , 1 , 'Invokes the method exactly once' ) ; assert . sameValue ( thisVal , obj ) ; assert . notSameValue ( args , undefined ) ; assert . sameValue ( args . length , 1 ) ; assert . sameValue ( args [ 0 ] , str ) ;"
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTstartsWith",
  "cond": "(= isRegExp true)",
  "covered": true,
  "elseCovered": "var s = Symbol ( ) ; assert . throws ( TypeError , function ( ) { '' . startsWith ( s ) ; } ) ;",
  "inst": "if (= isRegExp true) ... else ..."
}, {
  "algo": "GLOBALDOTSymbolDOTkeyFor",
  "cond": "(= cond true)",
  "covered": true,
  "inst": "if (= cond true) ... else ...",
  "thenCovered": "var canonical = Symbol . for ( 's' ) ; assert . sameValue ( Symbol . keyFor ( canonical ) , 's' ) ;"
}, {
  "algo": "GLOBALDOTSyntaxError",
  "cond": "(= NewTarget undefined)",
  "covered": true,
  "elseCovered": "assert . sameValue ( Object . getPrototypeOf ( new SyntaxError ) , SyntaxError . prototype ) ;",
  "inst": "if (= NewTarget undefined) ... else ..."
}, {
  "algo": "GLOBALDOTWeakMapDOTprototypeDOTdelete",
  "cond": "__x6__",
  "covered": true,
  "inst": "if __x6__ ... else ...",
  "thenCovered": "var map = new WeakMap ( ) ; var foo = { } ; var bar = { } ; map . set ( foo , 42 ) ; assert . sameValue ( map . delete ( bar ) , false ) ;"
}, {
  "algo": "GLOBALDOTWeakSetDOTprototypeDOTadd",
  "cond": "__x6__",
  "covered": true,
  "inst": "if __x6__ ... else ...",
  "thenCovered": "var foo = { } ; var s = new WeakSet ( [ foo ] ) ; assert . sameValue ( s . add ( foo ) , s , '`s.add(foo)` returns `s`' ) ;"
}, {
  "algo": "GLOBALDOTWeakSetDOTprototypeDOTdelete",
  "cond": "__x6__",
  "covered": true,
  "inst": "if __x6__ ... else ...",
  "thenCovered": "var foo = { } ; var s = new WeakSet ( [ foo ] ) ; var result = s . delete ( foo ) ; assert . sameValue ( s . has ( foo ) , false ) ; assert . sameValue ( result , true , 'WeakSet#delete returns true' ) ;"
}, {
  "algo": "GLOBALDOTWeakSetDOTprototypeDOTdelete",
  "cond": "__x6__",
  "covered": true,
  "inst": "if __x6__ ... else ...",
  "thenCovered": "var foo = { } ; var s = new WeakSet ( [ foo ] ) ; var result = s . delete ( foo ) ; assert . sameValue ( s . has ( foo ) , false ) ; assert . sameValue ( result , true , 'WeakSet#delete returns true' ) ;"
}, {
  "algo": "GeneratorResumeAbrupt",
  "cond": "(= genContext[\"ReturnCont\"] absent)",
  "covered": true,
  "elseCovered": "var first = 0 ; var second = 0 ; function * g ( ) { first += 1 ; yield ; second += 1 ; } ; var [ , ] = g ( ) ; assert . sameValue ( first , 1 ) ; assert . sameValue ( second , 0 ) ;",
  "inst": "if (= genContext[\"ReturnCont\"] absent) ... else ..."
}, {
  "algo": "GeneratorStart",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext) ... else ...",
  "thenCovered": "var iter = function * ( ) { } ( ) ; iter . next ( ) ; var [ , ] = iter ;"
}, {
  "algo": "GeneratorYield",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext) ... else ...",
  "thenCovered": "function * foo ( await ) { yield await ; } ; assert . sameValue ( foo ( 1 ) . next ( ) . value , 1 ) ;"
}, {
  "algo": "GetActiveScriptOrModule",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "elseCovered": "",
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ..."
}, {
  "algo": "GetActiveScriptOrModule",
  "cond": "(! (< k 0i))",
  "covered": true,
  "inst": "while (! (< k 0i)) { ... }",
  "thenCovered": ""
}, {
  "algo": "GetFunctionRealm",
  "cond": "(= (typeof obj) \"BoundFunctionExoticObject\")",
  "covered": true,
  "elseCovered": "class MyPromise extends Promise { static get [ Symbol . species ] ( ) { return Promise ; } } var p = Promise . resolve ( ) . finally ( ( ) => MyPromise . resolve ( ) ) ; assert . sameValue ( p instanceof Promise , true ) ; assert . sameValue ( p instanceof MyPromise , false ) ;",
  "inst": "if (= (typeof obj) \"BoundFunctionExoticObject\") ... else ..."
}, {
  "algo": "GetFunctionRealm",
  "cond": "(= (typeof obj) \"ProxyExoticObject\")",
  "covered": true,
  "elseCovered": "class MyPromise extends Promise { static get [ Symbol . species ] ( ) { return Promise ; } } var p = Promise . resolve ( ) . finally ( ( ) => MyPromise . resolve ( ) ) ; assert . sameValue ( p instanceof Promise , true ) ; assert . sameValue ( p instanceof MyPromise , false ) ;",
  "inst": "if (= (typeof obj) \"ProxyExoticObject\") ... else ..."
}, {
  "algo": "GetFunctionRealm",
  "cond": "(= obj[\"ProxyHandler\"] null)",
  "covered": false,
  "inst": "if (= obj[\"ProxyHandler\"] null) ... else ..."
}, {
  "algo": "GetIterator",
  "cond": "(= method undefined)",
  "covered": true,
  "inst": "if (= method undefined) ... else ...",
  "thenCovered": "function * g ( ) { } async function * asyncg ( ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%String.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%String.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Array.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Array.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Boolean.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Boolean.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Number.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Number.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Map.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Map.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Set.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Set.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%WeakMap.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%WeakMap.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%WeakSet.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%WeakSet.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Error.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Error.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%EvalError.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%EvalError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%ReferenceError.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%ReferenceError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%SyntaxError.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%SyntaxError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%TypeError.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%TypeError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%URIError.prototype%\")",
  "covered": true,
  "elseCovered": "function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%URIError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%AsyncGenerator.prototype%\")",
  "covered": true,
  "inst": "if (= intrinsicDefaultProto \"%AsyncGenerator.prototype%\") ... else ...",
  "thenCovered": "async function * g ( a = ( g . prototype = null ) ) { } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;"
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Promise.prototype%\")",
  "covered": false,
  "inst": "if (= intrinsicDefaultProto \"%Promise.prototype%\") ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= __x4__ true)",
  "covered": true,
  "elseCovered": "class await { }",
  "inst": "if (= __x4__ true) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= __x6__ true)",
  "covered": true,
  "elseCovered": "class await { }",
  "inst": "if (= __x6__ true) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= hasRestrictedGlobal true)",
  "covered": true,
  "elseCovered": "class await { }",
  "inst": "if (= hasRestrictedGlobal true) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= __x12__ true)",
  "covered": true,
  "elseCovered": "",
  "inst": "if (= __x12__ true) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= fnDefinable false)",
  "covered": true,
  "elseCovered": "",
  "inst": "if (= fnDefinable false) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= vnDefinable false)",
  "covered": true,
  "elseCovered": "",
  "inst": "if (= vnDefinable false) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTCanDeclareGlobalFunction",
  "cond": "(= existingProp[\"Configurable\"] true)",
  "covered": true,
  "inst": "if (= existingProp[\"Configurable\"] true) ... else ...",
  "thenCovered": "function Array ( ) { } var o = { x : 1 , y : 2 } ; var a = Object . keys ( o ) ; var s = Object . prototype . toString . call ( a ) ; assert . sameValue ( s , '[object Array]' , 's' ) ;"
}, {
  "algo": "GlobalEnvironmentRecordDOTCanDeclareGlobalFunction",
  "cond": "(&& (&& (= result true) (= existingProp[\"Writable\"] true)) (= existingProp[\"Enumerable\"] true))",
  "covered": false,
  "inst": "if (&& (&& (= result true) (= existingProp[\"Writable\"] true)) (= existingProp[\"Enumerable\"] true)) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateGlobalFunctionBinding",
  "cond": "(|| (= existingProp undefined) (= existingProp[\"Configurable\"] true))",
  "covered": true,
  "inst": "if (|| (= existingProp undefined) (= existingProp[\"Configurable\"] true)) ... else ...",
  "thenCovered": ""
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateGlobalFunctionBinding",
  "cond": "(! (= ObjRec[\"SubMap\"][N] absent))",
  "covered": true,
  "elseCovered": "",
  "inst": "if (! (= ObjRec[\"SubMap\"][N] absent)) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateGlobalFunctionBinding",
  "cond": "(! (contains varDeclaredNames N))",
  "covered": true,
  "inst": "if (! (contains varDeclaredNames N)) ... else ...",
  "thenCovered": ""
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateGlobalVarBinding",
  "cond": "(! (contains varDeclaredNames N))",
  "covered": true,
  "inst": "if (! (contains varDeclaredNames N)) ... else ...",
  "thenCovered": ""
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateImmutableBinding",
  "cond": "(= __x0__ true)",
  "covered": true,
  "elseCovered": "const [ x = 23 ] = [ ] ; assert . sameValue ( x , 23 ) ;",
  "inst": "if (= __x0__ true) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateMutableBinding",
  "cond": "(= __x0__ true)",
  "covered": true,
  "elseCovered": "class await { }",
  "inst": "if (= __x0__ true) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTHasRestrictedGlobalProperty",
  "cond": "(= existingProp undefined)",
  "covered": true,
  "inst": "if (= existingProp undefined) ... else ...",
  "thenCovered": "class await { }"
}, {
  "algo": "GlobalEnvironmentRecordDOTHasRestrictedGlobalProperty",
  "cond": "(= existingProp[\"Configurable\"] true)",
  "covered": false,
  "inst": "if (= existingProp[\"Configurable\"] true) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTHasVarDeclaration",
  "cond": "(contains varDeclaredNames N)",
  "covered": true,
  "elseCovered": "class await { }",
  "inst": "if (contains varDeclaredNames N) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTInitializeBinding",
  "cond": "(= __x0__ true)",
  "covered": true,
  "inst": "if (= __x0__ true) ... else ...",
  "thenCovered": "class await { }"
}, {
  "algo": "InitializeBoundName",
  "cond": "(! (= environment undefined))",
  "covered": true,
  "inst": "if (! (= environment undefined)) ... else ...",
  "thenCovered": "class await { }"
}, {
  "algo": "InstanceofOperator",
  "cond": "(= __x6__ false)",
  "covered": true,
  "inst": "if (= __x6__ false) ... else ...",
  "thenCovered": "var F = { } ; F [ Symbol . hasInstance ] = null ; assert . throws ( TypeError , function ( ) { 0 instanceof F ; } ) ;"
}, {
  "algo": "IsAccessorDescriptor",
  "cond": "(= Desc undefined)",
  "covered": true,
  "elseCovered": "",
  "inst": "if (= Desc undefined) ... else ..."
}, {
  "algo": "IsArray",
  "cond": "(= (typeof argument) \"ProxyExoticObject\")",
  "covered": true,
  "elseCovered": "1 * { } ;",
  "inst": "if (= (typeof argument) \"ProxyExoticObject\") ... else ..."
}, {
  "algo": "IsArray",
  "cond": "(= argument[\"ProxyHandler\"] null)",
  "covered": false,
  "inst": "if (= argument[\"ProxyHandler\"] null) ... else ..."
}, {
  "algo": "IsDataDescriptor",
  "cond": "(= Desc undefined)",
  "covered": true,
  "elseCovered": "",
  "inst": "if (= Desc undefined) ... else ..."
}, {
  "algo": "IsDuplicate",
  "cond": "(= list[i] list[j])",
  "covered": true,
  "elseCovered": "assert ( NaN !== NaN ) ;",
  "inst": "if (= list[i] list[j]) ... else ..."
}, {
  "algo": "IsGenericDescriptor",
  "cond": "(= Desc undefined)",
  "covered": true,
  "elseCovered": "",
  "inst": "if (= Desc undefined) ... else ..."
}, {
  "algo": "IsInTailPosition",
  "cond": "(is-instance-of __x1__ AsyncConciseBody)",
  "covered": true,
  "elseCovered": "Object . keys ( 0 ) ;",
  "inst": "if (is-instance-of __x1__ AsyncConciseBody) ... else ..."
}, {
  "algo": "IsInTailPosition",
  "cond": "(is-instance-of __x3__ AsyncConciseBody)",
  "covered": true,
  "elseCovered": "assert . sameValue ( 0 , 0 ) ;",
  "inst": "if (is-instance-of __x3__ AsyncConciseBody) ... else ..."
}, {
  "algo": "IsInTailPosition",
  "cond": "(is-instance-of body AsyncConciseBody)",
  "covered": true,
  "elseCovered": "assert . sameValue ( 0 , 0 ) ;",
  "inst": "if (is-instance-of body AsyncConciseBody) ... else ..."
}, {
  "algo": "IsNonNegativeInteger",
  "cond": "(&& (= __x0__ true) (! (< argument 0i)))",
  "covered": true,
  "inst": "if (&& (= __x0__ true) (! (< argument 0i))) ... else ...",
  "thenCovered": ""
}, {
  "algo": "IsPropertyKey",
  "cond": "(= __x2__ Symbol)",
  "covered": true,
  "inst": "if (= __x2__ Symbol) ... else ...",
  "thenCovered": "1 * { } ;"
}, {
  "algo": "IsRegExp",
  "cond": "(! (= matcher undefined))",
  "covered": true,
  "elseCovered": "var obj = { toString : function ( ) { throw new Test262Error ( ) ; } } ; assert . throws ( Test262Error , function ( ) { '' . includes ( obj ) ; } ) ;",
  "inst": "if (! (= matcher undefined)) ... else ..."
}, {
  "algo": "IsRegExp",
  "cond": "(! (= argument[\"RegExpMatcher\"] absent))",
  "covered": true,
  "elseCovered": "var obj = { toString : function ( ) { throw new Test262Error ( ) ; } } ; assert . throws ( Test262Error , function ( ) { '' . includes ( obj ) ; } ) ;",
  "inst": "if (! (= argument[\"RegExpMatcher\"] absent)) ... else ..."
}, {
  "algo": "LabelledItem0TopLevelVarDeclaredNames0",
  "cond": "(is-instance-of Statement Statement10)",
  "covered": true,
  "elseCovered": "await : 1 ;",
  "inst": "if (is-instance-of Statement Statement10) ... else ..."
}, {
  "algo": "LabelledItem0TopLevelVarScopedDeclarations0",
  "cond": "(is-instance-of Statement Statement10)",
  "covered": true,
  "elseCovered": "await : 1 ;",
  "inst": "if (is-instance-of Statement Statement10) ... else ..."
}, {
  "algo": "MakeBasicObject",
  "cond": "(contains internalSlotsList \"Extensible\")",
  "covered": true,
  "inst": "if (contains internalSlotsList \"Extensible\") ... else ...",
  "thenCovered": ""
}, {
  "algo": "MemberExpression3HasCallInTailPosition0",
  "cond": "(= this call)",
  "covered": true,
  "inst": "if (= this call) ... else ...",
  "thenCovered": "( function ( ) { var finished = false ; function f ( _ , n ) { if ( n === 0 ) { finished = true ; return ; } return f `${ n - 1 }` ; } f ( null , $MAX_ITERATIONS ) ; return finished ; } ( ) ) ;"
}, {
  "algo": "ObjectEnvironmentRecordDOTGetBindingValue",
  "cond": "(= value false)",
  "covered": true,
  "elseCovered": "",
  "inst": "if (= value false) ... else ..."
}, {
  "algo": "ObjectEnvironmentRecordDOTGetBindingValue",
  "cond": "(= S false)",
  "covered": false,
  "inst": "if (= S false) ... else ..."
}, {
  "algo": "ObjectEnvironmentRecordDOTHasBinding",
  "cond": "(= envRec[\"withEnvironment\"] false)",
  "covered": true,
  "inst": "if (= envRec[\"withEnvironment\"] false) ... else ...",
  "thenCovered": ""
}, {
  "algo": "ObjectEnvironmentRecordDOTHasBinding",
  "cond": "(= __x4__ Object)",
  "covered": false,
  "inst": "if (= __x4__ Object) ... else ..."
}, {
  "algo": "ObjectEnvironmentRecordDOTHasBinding",
  "cond": "(= blocked true)",
  "covered": false,
  "inst": "if (= blocked true) ... else ..."
}, {
  "algo": "ObjectEnvironmentRecordDOTInitializeBinding",
  "cond": "(! (= envRec[\"SubMap\"][N] absent))",
  "covered": true,
  "elseCovered": "",
  "inst": "if (! (= envRec[\"SubMap\"][N] absent)) ... else ..."
}, {
  "algo": "OrdinaryCallBindThis",
  "cond": "(= thisMode CONST_strict)",
  "covered": true,
  "inst": "if (= thisMode CONST_strict) ... else ...",
  "thenCovered": "assert ( NaN !== NaN ) ;"
}, {
  "algo": "OrdinaryCallBindThis",
  "cond": "(|| (= thisArgument undefined) (= thisArgument null))",
  "covered": false,
  "inst": "if (|| (= thisArgument undefined) (= thisArgument null)) ... else ..."
}, {
  "algo": "OrdinaryFunctionCreate",
  "cond": "(= Strict true)",
  "covered": true,
  "inst": "if (= Strict true) ... else ...",
  "thenCovered": ""
}, {
  "algo": "OrdinarySetPrototypeOf",
  "cond": "(= __x0__ true)",
  "covered": true,
  "elseCovered": "var obj = { } ; Object . preventExtensions ( obj ) ; assert . throws ( TypeError , function ( ) { Object . setPrototypeOf ( obj , null ) ; } ) ;",
  "inst": "if (= __x0__ true) ... else ..."
}, {
  "algo": "OrdinarySetPrototypeOf",
  "cond": "(= __x3__ true)",
  "covered": true,
  "elseCovered": "var proto = { p4 : 'p4' , } ; var o = { p1 : 'p1' , p2 : 'p2' , p3 : 'p3' , } ; Object . setPrototypeOf ( o , proto ) ; var keys = [ ] ; for ( var key in o ) { keys . push ( key ) ; } assert . compareArray ( keys , [ 'p1' , 'p2' , 'p3' , 'p4' ] ) ;",
  "inst": "if (= __x3__ true) ... else ..."
}, {
  "algo": "OrdinarySetPrototypeOf",
  "cond": "(! (= p[\"GetProtoTypeOf\"] OrdinaryObjectDOTGetPrototypeOf))",
  "covered": true,
  "inst": "if (! (= p[\"GetProtoTypeOf\"] OrdinaryObjectDOTGetPrototypeOf)) ... else ...",
  "thenCovered": "var proto = { p4 : 'p4' , } ; var o = { p1 : 'p1' , p2 : 'p2' , p3 : 'p3' , } ; Object . setPrototypeOf ( o , proto ) ; var keys = [ ] ; for ( var key in o ) { keys . push ( key ) ; } assert . compareArray ( keys , [ 'p1' , 'p2' , 'p3' , 'p4' ] ) ;"
}, {
  "algo": "OrdinarySetWithOwnDescriptor",
  "cond": "(= __x9__ true)",
  "covered": true,
  "elseCovered": "",
  "inst": "if (= __x9__ true) ... else ..."
}, {
  "algo": "OrdinarySetWithOwnDescriptor",
  "cond": "(= existingDescriptor[\"Writable\"] false)",
  "covered": true,
  "elseCovered": "",
  "inst": "if (= existingDescriptor[\"Writable\"] false) ... else ..."
}, {
  "algo": "PerformEval",
  "cond": "(= F[\"ConstructorKind\"] CONST_derived)",
  "covered": true,
  "elseCovered": "var s = eval ; s ( 'var eval;' ) ;",
  "inst": "if (= F[\"ConstructorKind\"] CONST_derived) ... else ..."
}, {
  "algo": "PerformEval",
  "cond": "__x17__",
  "covered": true,
  "inst": "if __x17__ ... else ...",
  "thenCovered": "let x ; eval ( 'var x;' ) ;"
}, {
  "algo": "PerformEval",
  "cond": "(= strictEval true)",
  "covered": true,
  "inst": "if (= strictEval true) ... else ...",
  "thenCovered": "let x ; eval ( 'var x;' ) ;"
}, {
  "algo": "PerformEval",
  "cond": "(= runningContext null)",
  "covered": true,
  "elseCovered": "let x ; eval ( 'var x;' ) ;",
  "inst": "if (= runningContext null) ... else ..."
}, {
  "algo": "PerformEval",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] evalContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] evalContext) ... else ...",
  "thenCovered": "let x ; eval ( 'var x;' ) ;"
}, {
  "algo": "PerformEval",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "elseCovered": "let x ; eval ( 'var x;' ) ;",
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ..."
}, {
  "algo": "PerformPromiseAll",
  "cond": "(= __x2__ false)",
  "covered": true,
  "elseCovered": "var p = Promise . all ( [ ] ) ; if ( ! ( p instanceof Promise ) ) { $ERROR ( 'Expected p to be a Promise' ) ; }",
  "inst": "if (= __x2__ false) ... else ..."
}, {
  "algo": "PerformPromiseAllSettled",
  "cond": "(= __x2__ false)",
  "covered": true,
  "elseCovered": "var p = Promise . allSettled ( [ ] ) ; assert ( p instanceof Promise ) ; assert . sameValue ( Object . getPrototypeOf ( p ) , Promise . prototype ) ;",
  "inst": "if (= __x2__ false) ... else ..."
}, {
  "algo": "PerformPromiseRace",
  "cond": "(= __x2__ false)",
  "covered": true,
  "elseCovered": "var p = Promise . race ( [ ] ) ; if ( ! ( p instanceof Promise ) ) { $ERROR ( \"Expected Promise.race([]) to return a promise.\" ) ; }",
  "inst": "if (= __x2__ false) ... else ..."
}, {
  "algo": "PerformPromiseThen",
  "cond": "(= promise[\"PromiseIsHandled\"] false)",
  "covered": true,
  "inst": "if (= promise[\"PromiseIsHandled\"] false) ... else ...",
  "thenCovered": "class FooPromise extends Promise { static get [ Symbol . species ] ( ) { return Promise ; } } var p = Promise . reject ( ) . finally ( ( ) => FooPromise . reject ( ) ) ; assert . sameValue ( p instanceof Promise , true ) ; assert . sameValue ( p instanceof FooPromise , false ) ;"
}, {
  "algo": "PrepareForOrdinaryCall",
  "cond": "(= callerContext null)",
  "covered": true,
  "elseCovered": "assert ( NaN !== NaN ) ;",
  "inst": "if (= callerContext null) ... else ..."
}, {
  "algo": "PrepareForTailCall",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] leafContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] leafContext) ... else ...",
  "thenCovered": "assert . throws ( TypeError , function ( ) { Promise . all . call ( eval ) ; } ) ;"
}, {
  "algo": "PrepareForTailCall",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "elseCovered": "assert . throws ( TypeError , function ( ) { Promise . all . call ( eval ) ; } ) ;",
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ..."
}, {
  "algo": "PromiseReactionJob",
  "cond": "(= type CONST_Fulfill)",
  "covered": true,
  "elseCovered": "class FooPromise extends Promise { static get [ Symbol . species ] ( ) { return Promise ; } } var p = Promise . reject ( ) . finally ( ( ) => FooPromise . reject ( ) ) ; assert . sameValue ( p instanceof Promise , true ) ; assert . sameValue ( p instanceof FooPromise , false ) ;",
  "inst": "if (= type CONST_Fulfill) ... else ..."
}, {
  "algo": "PropertyDefinition3Contains0",
  "cond": "(is-instance-of symbol MethodDefinition)",
  "covered": true,
  "elseCovered": "eval ( \"({foo : 1, get foo(){}});\" ) ;",
  "inst": "if (is-instance-of symbol MethodDefinition) ... else ..."
}, {
  "algo": "PutValue",
  "cond": "(! (= __x0__ Reference))",
  "covered": true,
  "elseCovered": "",
  "inst": "if (! (= __x0__ Reference)) ... else ..."
}, {
  "algo": "PutValue",
  "cond": "(= __x4__ true)",
  "covered": true,
  "inst": "if (= __x4__ true) ... else ...",
  "thenCovered": "assert . throws ( ReferenceError , function ( ) { b = 11 ; } ) ;"
}, {
  "algo": "RunJobs",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] GLOBAL_context)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] GLOBAL_context) ... else ...",
  "thenCovered": ""
}, {
  "algo": "RunJobs",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ...",
  "thenCovered": ""
}, {
  "algo": "ScriptEvaluation",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] scriptContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] scriptContext) ... else ...",
  "thenCovered": ""
}, {
  "algo": "ScriptEvaluation",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "elseCovered": "",
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ..."
}, {
  "algo": "SetIntegrityLevel",
  "cond": "(= status false)",
  "covered": true,
  "elseCovered": "assert . sameValue ( String . raw `` , '' ) ;",
  "inst": "if (= status false) ... else ..."
}, {
  "algo": "SetIntegrityLevel",
  "cond": "(! (= currentDesc undefined))",
  "covered": true,
  "inst": "if (! (= currentDesc undefined)) ... else ...",
  "thenCovered": "assert . sameValue ( String . raw `` , '' ) ;"
}, {
  "algo": "SetRealmGlobalObject",
  "cond": "(= globalObj undefined)",
  "covered": true,
  "inst": "if (= globalObj undefined) ... else ...",
  "thenCovered": ""
}, {
  "algo": "SetRealmGlobalObject",
  "cond": "(= thisValue undefined)",
  "covered": true,
  "inst": "if (= thisValue undefined) ... else ...",
  "thenCovered": ""
}, {
  "algo": "SpeciesConstructor",
  "cond": "(= C undefined)",
  "covered": true,
  "elseCovered": "var p1 = new Promise ( function ( ) { } ) ; delete p1 . constructor ; var p2 = p1 . then ( ) ; assert ( p2 instanceof Promise ) ;",
  "inst": "if (= C undefined) ... else ..."
}, {
  "algo": "SpeciesConstructor",
  "cond": "(= __x7__ true)",
  "covered": true,
  "inst": "if (= __x7__ true) ... else ...",
  "thenCovered": "var p1 = new Promise ( function ( ) { } ) ; delete p1 . constructor ; var p2 = p1 . then ( ) ; assert ( p2 instanceof Promise ) ;"
}, {
  "algo": "StringExoticObjectDOTOwnPropertyKeys",
  "cond": "(! (< n str[\"length\"]))",
  "covered": true,
  "inst": "if (! (< n str[\"length\"])) ... else ...",
  "thenCovered": "var str = new String ( \"abc\" ) ; str [ 5 ] = \"de\" ; var expected = [ \"0\" , \"1\" , \"2\" , \"5\" , \"length\" ] ; var actual = Object . getOwnPropertyNames ( str ) ; assert ( compareArray ( actual , expected ) , 'compareArray(actual, expected) !== true' ) ;"
}, {
  "algo": "StringExoticObjectDOTOwnPropertyKeys",
  "cond": "(< j len)",
  "covered": true,
  "elseCovered": "var str = new String ( \"abc\" ) ; str [ 5 ] = \"de\" ; var expected = [ \"0\" , \"1\" , \"2\" , \"5\" , \"length\" ] ; var actual = Object . getOwnPropertyNames ( str ) ; assert ( compareArray ( actual , expected ) , 'compareArray(actual, expected) !== true' ) ;",
  "inst": "while (< j len) { ... }"
}, {
  "algo": "StringExoticObjectDOTOwnPropertyKeys",
  "cond": "(< arrayIndexKeys[j] arrayIndexKeys[min])",
  "covered": false,
  "inst": "if (< arrayIndexKeys[j] arrayIndexKeys[min]) ... else ..."
}, {
  "algo": "StringGetOwnProperty",
  "cond": "(= index -0.0)",
  "covered": true,
  "elseCovered": "Object . keys ( 'abc' ) ;",
  "inst": "if (= index -0.0) ... else ..."
}, {
  "algo": "SuperProperty1Contains0",
  "cond": "(= symbol \"super\")",
  "covered": true,
  "elseCovered": "var superProp = null ; var o = { test262 : null , method ( ) { superProp = eval ( 'super.test262;' ) ; } } ; o . method ( ) ; assert . sameValue ( superProp , undefined ) ; Object . setPrototypeOf ( o , { test262 : 262 } ) ; o . method ( ) ; assert . sameValue ( superProp , 262 ) ;",
  "inst": "if (= symbol \"super\") ... else ..."
}, {
  "algo": "SuperProperty1Contains0",
  "cond": "(is-instance-of symbol ReservedWord)",
  "covered": true,
  "elseCovered": "var superProp = null ; var o = { test262 : null , method ( ) { superProp = eval ( 'super.test262;' ) ; } } ; o . method ( ) ; assert . sameValue ( superProp , undefined ) ; Object . setPrototypeOf ( o , { test262 : 262 } ) ; o . method ( ) ; assert . sameValue ( superProp , 262 ) ;",
  "inst": "if (is-instance-of symbol ReservedWord) ... else ..."
}, {
  "algo": "SuperProperty1Contains0",
  "cond": "__x0__",
  "covered": true,
  "elseCovered": "var superProp = null ; var o = { test262 : null , method ( ) { superProp = eval ( 'super.test262;' ) ; } } ; o . method ( ) ; assert . sameValue ( superProp , undefined ) ; Object . setPrototypeOf ( o , { test262 : 262 } ) ; o . method ( ) ; assert . sameValue ( superProp , 262 ) ;",
  "inst": "if __x0__ ... else ..."
}, {
  "algo": "SuperProperty1Contains0",
  "cond": "__x0__",
  "covered": true,
  "elseCovered": "var superProp = null ; var o = { test262 : null , method ( ) { superProp = eval ( 'super.test262;' ) ; } } ; o . method ( ) ; assert . sameValue ( superProp , undefined ) ; Object . setPrototypeOf ( o , { test262 : 262 } ) ; o . method ( ) ; assert . sameValue ( superProp , 262 ) ;",
  "inst": "if __x0__ ... else ..."
}, {
  "algo": "TestIntegrityLevel",
  "cond": "(! (= currentDesc undefined))",
  "covered": true,
  "inst": "if (! (= currentDesc undefined)) ... else ...",
  "thenCovered": "var obj = Object . freeze ( [ 0 , 1 , 2 ] ) ; assert ( Object . isFrozen ( obj ) , 'Object.isFrozen(obj) !== true' ) ;"
}, {
  "algo": "ToInteger",
  "cond": "(= integer -0.0)",
  "covered": true,
  "elseCovered": "var [ x = 23 ] = [ , ] ; assert . sameValue ( x , 23 ) ;",
  "inst": "if (= integer -0.0) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"HasProperty\"] absent)",
  "covered": true,
  "elseCovered": "var x = \"\" . search ( ) ;",
  "inst": "if (= obj[\"HasProperty\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"DefineOwnProperty\"] absent)",
  "covered": true,
  "elseCovered": "var x = \"\" . search ( ) ;",
  "inst": "if (= obj[\"DefineOwnProperty\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"Set\"] absent)",
  "covered": true,
  "elseCovered": "var x = \"\" . search ( ) ;",
  "inst": "if (= obj[\"Set\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"SetPrototypeOf\"] absent)",
  "covered": true,
  "elseCovered": "var x = \"\" . search ( ) ;",
  "inst": "if (= obj[\"SetPrototypeOf\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"Get\"] absent)",
  "covered": true,
  "elseCovered": "var x = \"\" . search ( ) ;",
  "inst": "if (= obj[\"Get\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"PreventExtensions\"] absent)",
  "covered": true,
  "elseCovered": "var x = \"\" . search ( ) ;",
  "inst": "if (= obj[\"PreventExtensions\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"Delete\"] absent)",
  "covered": true,
  "elseCovered": "var x = \"\" . search ( ) ;",
  "inst": "if (= obj[\"Delete\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"GetOwnProperty\"] absent)",
  "covered": true,
  "elseCovered": "var x = \"\" . search ( ) ;",
  "inst": "if (= obj[\"GetOwnProperty\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"OwnPropertyKeys\"] absent)",
  "covered": true,
  "elseCovered": "var x = \"\" . search ( ) ;",
  "inst": "if (= obj[\"OwnPropertyKeys\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"GetPrototypeOf\"] absent)",
  "covered": true,
  "elseCovered": "var x = \"\" . search ( ) ;",
  "inst": "if (= obj[\"GetPrototypeOf\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"IsExtensible\"] absent)",
  "covered": true,
  "elseCovered": "var x = \"\" . search ( ) ;",
  "inst": "if (= obj[\"IsExtensible\"] absent) ... else ..."
}, {
  "algo": "TryStatement1VarDeclaredNames0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "var numBak = Number ; try { Number = 12 ; } finally { Number = numBak ; }",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "TryStatement1VarScopedDeclarations0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "var numBak = Number ; try { Number = 12 ; } finally { Number = numBak ; }",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "TryStatement2VarDeclaredNames0",
  "cond": "(< __x7__ __x6__[\"length\"])",
  "covered": true,
  "elseCovered": "try { } catch { } finally { }",
  "inst": "while (< __x7__ __x6__[\"length\"]) { ... }"
}, {
  "algo": "TryStatement2VarScopedDeclarations0",
  "cond": "(< __x7__ __x6__[\"length\"])",
  "covered": true,
  "elseCovered": "try { } catch { } finally { }",
  "inst": "while (< __x7__ __x6__[\"length\"]) { ... }"
}, {
  "algo": "ValidateAndApplyPropertyDescriptor",
  "cond": "(! (= O undefined))",
  "covered": true,
  "inst": "if (! (= O undefined)) ... else ...",
  "thenCovered": ""
}, {
  "algo": "ValidateAndApplyPropertyDescriptor",
  "cond": "(! (= O undefined))",
  "covered": true,
  "inst": "if (! (= O undefined)) ... else ...",
  "thenCovered": "assert ( NaN !== NaN ) ;"
}, {
  "algo": "ValidateAndApplyPropertyDescriptor",
  "cond": "(! (= O undefined))",
  "covered": true,
  "inst": "if (! (= O undefined)) ... else ...",
  "thenCovered": "eval ( \"({foo : 1, get foo(){}});\" ) ;"
}, {
  "algo": "ValidateAndApplyPropertyDescriptor",
  "cond": "(! (= O undefined))",
  "covered": true,
  "inst": "if (! (= O undefined)) ... else ...",
  "thenCovered": "void { get foo ( ) { } , foo : 1 } ;"
}, {
  "algo": "YieldExpression0Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var first = 0 ; var second = 0 ; function * g ( ) { first += 1 ; yield ; second += 1 ; } ; var [ , ] = g ( ) ; assert . sameValue ( first , 1 ) ; assert . sameValue ( second , 0 ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression1Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "function * foo ( await ) { yield await ; } ; assert . sameValue ( foo ( 1 ) . next ( ) . value , 1 ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var badIter = { } ; badIter [ Symbol . iterator ] = function ( ) { return { next : function ( ) { return { done : false } ; } , return : function ( ) { throw 87 ; } } ; } ; function * g ( ) { try { yield * badIter ; } catch ( err ) { caught = err ; } } var iter = g ( ) ; var caught ; iter . next ( ) ; iter . throw ( ) ; assert . sameValue ( caught , 87 ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var quickIter = { } ; var iter , exprValue , throwReceived ; quickIter [ Symbol . iterator ] = function ( ) { return { next : function ( ) { return { done : false } ; } , throw : function ( x ) { throwReceived = x ; return { done : true , value : 3333 } ; } } ; } ; function * g ( ) { exprValue = yield * quickIter ; } iter = g ( ) ; iter . next ( ) ; iter . throw ( 2222 ) ; assert . sameValue ( throwReceived , 2222 ) ; assert . sameValue ( exprValue , 3333 ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var badIter = { } ; var callCount = 0 ; var spyValue = Object . defineProperty ( { done : false } , 'value' , { get : function ( ) { callCount += 1 ; } } ) ; badIter [ Symbol . iterator ] = function ( ) { return { next : function ( ) { return { done : false } ; } , throw : function ( ) { return spyValue ; } } ; } ; var delegationComplete = false ; function * g ( ) { yield * badIter ; delegationComplete = true ; } var iter = g ( ) ; iter . next ( ) ; assert . sameValue ( callCount , 0 , 'access count (first iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (first iteration)' ) ; iter . throw ( ) ; assert . sameValue ( callCount , 0 , 'access count (second iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (second iteration)' ) ; spyValue . done = true ; iter . throw ( ) ; assert . sameValue ( callCount , 1 , 'access count (final iteration)' ) ; assert . sameValue ( delegationComplete , true , 'delegation complete' ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var badIter = { } ; badIter [ Symbol . iterator ] = function ( ) { return { next : function ( ) { return { done : false } ; } , return : function ( ) { throw 87 ; } } ; } ; function * g ( ) { try { yield * badIter ; } catch ( err ) { caught = err ; } } var iter = g ( ) ; var caught ; iter . next ( ) ; iter . throw ( ) ; assert . sameValue ( caught , 87 ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var badIter = { } ; var throwCount = 0 ; var returnCount = 0 ; var hitNextStatement = false ; var hitCatch = false ; var hitFinally = false ; var spyResult = { next : function ( ) { return { done : false } ; } } ; Object . defineProperty ( spyResult , 'throw' , { get : function ( ) { throwCount += 1 ; } } ) ; Object . defineProperty ( spyResult , 'return' , { get : function ( ) { returnCount += 1 ; } } ) ; badIter [ Symbol . iterator ] = function ( ) { return spyResult ; } ; function * g ( ) { try { yield * badIter ; hitNextStatement = true ; } catch ( _ ) { hitCatch = true ; } finally { hitFinally = true ; } } var iter = g ( ) ; iter . next ( ) ; iter . return ( ) ; assert . sameValue ( throwCount , 0 , '`throw` property access' ) ; assert . sameValue ( returnCount , 1 , '`return` property access' ) ; assert . sameValue ( hitFinally , true , 'Generator execution was resumed' ) ; assert . sameValue ( hitNextStatement , false , 'Abrupt completion interrupted control flow' ) ; assert . sameValue ( hitCatch , false , 'Abrupt completion not interpreted as \"throw\"' ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var thrown = new Test262Error ( ) ; var badIter = { } ; var poisonedDone = Object . defineProperty ( { } , 'done' , { get : function ( ) { throw thrown ; } } ) ; badIter [ Symbol . iterator ] = function ( ) { return { next : function ( ) { return { done : false } ; } , return : function ( ) { return poisonedDone ; } } ; } ; function * g ( ) { try { yield * badIter ; } catch ( err ) { caught = err ; } } var iter = g ( ) ; var caught ; iter . next ( ) ; iter . return ( ) ; assert . sameValue ( caught , thrown ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var badIter = { } ; var callCount = 0 ; var spyValue = Object . defineProperty ( { done : false } , 'value' , { get : function ( ) { callCount += 1 ; } } ) ; badIter [ Symbol . iterator ] = function ( ) { return { next : function ( ) { return { done : false } ; } , return : function ( ) { return spyValue ; } } ; } ; var normalCompletion = false ; var errorCompletion = false ; var delegationComplete = false ; function * g ( ) { try { yield * badIter ; normalCompletion = true ; } catch ( _ ) { errorCompletion = true ; } finally { delegationComplete = true ; } } var iter = g ( ) ; iter . next ( ) ; assert . sameValue ( callCount , 0 , 'access count (first iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (first iteration)' ) ; iter . return ( ) ; assert . sameValue ( callCount , 0 , 'access count (second iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (second iteration)' ) ; spyValue . done = true ; iter . return ( ) ; assert . sameValue ( callCount , 1 , 'access count (final iteration)' ) ; assert . sameValue ( delegationComplete , true , 'delegation complete' ) ; assert . sameValue ( normalCompletion , false , 'completion was abrupt' ) ; assert . sameValue ( errorCompletion , false , 'completion was not of type \"throw\"' ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}]