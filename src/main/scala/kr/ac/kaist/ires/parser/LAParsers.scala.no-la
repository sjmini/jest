package kr.ac.kaist.ires.parser

import kr.ac.kaist.ires.util.Useful._
import kr.ac.kaist.ires.{ DEBUG_PARSER, DEBUG_SEMI_INSERT, LINE_SEP }
import scala.collection.mutable
import scala.language.reflectiveCalls
import scala.util.parsing.input._

trait LAParsers extends Lexer {
  // failed parser
  val failed: Parser[Nothing] = failure("")

  // lookahead parsers
  trait LAParser[+T] { self =>
    val parser: Parser[T]

    def ~[U](that: => LAParser[U]): LAParser[T ~ U] = new LAParser[T ~ U] {
      val parser = self.parser ~ that.parser
    }

    def ~>[U](that: => LAParser[U]): LAParser[U] = new LAParser[U] {
      val parser = self.parser ~> that.parser
    }

    def <~[U](that: => LAParser[U]): LAParser[T] = new LAParser[T] {
      val parser = self.parser <~ that.parser
    }

    def |[U >: T](that: LAParser[U]): LAParser[U] =
      if (that eq MISMATCH) self
      else new LAParser[U] {
        val parser = self.parser ||| that.parser
      }

    def ^^[U](f: T => U): LAParser[U] = new LAParser[U] {
      val parser = self.parser ^^ f
    }

    def ^^^[U](v: => U): LAParser[U] = new LAParser[U] {
      val parser = self.parser ^^^ v
    }

    def apply(in: EPackratReader[Char]): ParseResult[T] = parser(in)

    def unary_-(): LAParser[Unit] = new LAParser[Unit] {
      val parser = not(self.parser)
    }

    def unary_+(): LAParser[T] = new LAParser[T] {
      val parser = guard(self.parser)
    }
  }

  // always match
  lazy val MATCH: LAParser[String] = log(new LAParser[String] {
    val parser = ""
  })("MATCH")

  // always mismatch
  lazy val MISMATCH: LAParser[Nothing] = log(new LAParser[Nothing] {
    val parser = failed
  })("MISMATCH")

  // optional parsers
  def opt[T](p: => LAParser[T]): LAParser[Option[T]] = p ^^ { Some(_) } | MATCH ^^^ None

  // memoization of lookahead parsers
  def memo[T](p: => LAParser[T]): LAParser[T] = new LAParser[T] {
    val parser = {
      lazy val q = p
      memo(Parser { in => q.parser(in) })
    }
  }

  // logging
  var keepLog: Boolean = true
  def log[T](p: LAParser[T])(name: String): LAParser[T] =
    if (!DEBUG_PARSER) p
    else new LAParser[T] {
      val parser = Parser { rawIn =>
        val in = rawIn.asInstanceOf[EPackratReader[Char]]
        val stopMsg = s"trying $name at [${in.pos}] \n\n${in.pos.longString}\n"
        if (keepLog) stop(stopMsg) match {
          case "q" =>
            keepLog = false
            p(in)
          case "j" =>
            keepLog = false
            val r = p(in)
            printlnCyan(name + " --> " + r)
            keepLog = true
            r
          case _ =>
            val r = p(in)
            printlnCyan(name + " --> " + r)
            r
        }
        else p(in)
      }
    }

  // stop message
  protected def stop(msg: String): String = {
    printlnCyan(msg)
    scala.io.StdIn.readLine
  }

  // Parse charater reader `in` with parser `p`
  def parse[T](p: LAParser[T], in: Reader[Char]): ParseResult[T] = {
    p(new EPackratReader(in))
  }

  // Parse character sequence `in` with parser `p`
  def parse[T](p: LAParser[T], in: java.lang.CharSequence): ParseResult[T] =
    parse(p, new CharSequenceReader(in))

  // Parse reader `in` with parser `p`
  def parse[T](p: LAParser[T], in: java.io.Reader): ParseResult[T] =
    parse(p, new PagedSeqReader(PagedSeq.fromReader(in)))

  // record parsing process
  protected def record[T](parser: Parser[T], in: EPackratReader[Char]): ParseResult[T]

  // terminal lexer
  protected val TERMINAL: Lexer
}
